# The MIT License (MIT)
#
# Copyright (c) 2012-2021 https://github.com/rbf
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# SOURCE:     https://github.com/rbf/dotfiles/blob/master/git
# RAW:        https://raw.githubusercontent.com/rbf/dotfiles/master/git/.gitconfig
# SHORTLINK:  http://rbf.li/gitconfig

# Git uses a series of configuration files to determine non-default behavior that
# you may want. These config files can be stored in three different places:
#
#   1) /etc/gitconfig file: for every user on the system and all their repositories.
#   2) ~/.gitconfig file: Specific to your user.
#   3) .git/config a given repository: Specific to that single repository.
#
# Each level overwrites values in the previous level, so values in .git/config
# trump those in /etc/gitconfig, for instance.
#
# (From: http://git-scm.com/book/en/Getting-Started-First-Time-Git-Setup
#        http://git-scm.com/book/ch7-1.html)
#
# More info on git-config file and syntax:
#   https://www.kernel.org/pub/software/scm/git/docs/git-config.html
#
# Run the following command to download and install this file for the current
# user (while saving the current .gitconfig file as .gitconfig.local, if any):
#
#     [ -f ~/.gitconfig ] && cat ~/.gitconfig >> ~/.gitconfig.local; curl -#SL rbf.li/gitconfig -o ~/.gitconfig
#
# You can also find this simple installer on rbf.li/gitconfiginstall or shorter
# at rbf.li/gci. If you trust the content of the link, that you can directly do:
#
#     bash <(curl -sSL rbf.li/gci)
#
# Please DO NOT MODIFY or customize this file because your changes will be lost
# when you update it with 'git update-gitconfig'. Instead create a file named
# '.gitconfig.local' in the same directory as the current '.gitconfig' and add
# your customizations (including your username and email) in that file.

# Configure user.name and user.email in the .gitconfig.local as exaplined above.
# [user]
#   name =
#   email =

[core]
  editor = /usr/bin/vim
  excludesfile = ~/.gitignore
  # Enable wrap when displaying text, e.g. with "git diff"
  # SOURCE: http://iamnearlythere.com/wrapping-lines-git-diff/
  # SOURCE: 03oct2021 https://stackoverflow.com/a/18781512
  pager = less -FRXK

[checkout]
  # Setting a default remote is useful only when several remotes are setup, e.g.
  # 'origin' and 'upstream'. It allows to write:
  #   - 'git checkout <branch>' instead of 'git checkout --track <remote>/<branch>'
  #   - 'git worktree add <path> <branch>' instead of 'git worktree add --track -b <branch> <path> <remote>/<branch>'
  # DOC: See 'checkout.defaultRemote' in 'git config --help'.
  # DOC: See 'add' in 'git worktree --help'.
  # DOC: See '--guess' in 'git checkout --help'.
  # SOURCE: 21oct2021 https://stackoverflow.com/a/60724734
  defaultRemote = origin

[diff]
  # Interesting geeky read about diff algorithms: http://fabiensanglard.net/git_code_review/diff.php
  # DOC: https://git-scm.com/docs/git-config#git-config-diffalgorithm
  algorithm = histogram
  colorMoved = default

[pager]
    diff = delta
    log = delta
    reflog = delta
    # Use 'git view' to use delta.
    show = less -FRXK

[interactive]
    diffFilter = delta --color-only

# Configuration for delta diff helper tool.
# SOURCE: 28jun2021 https://github.com/dandavison/delta

[delta]
  side-by-side = false
  line-numbers = true
  features = decorations

# Available style options for delta (each accepts foreground, background and attributes)
#
# - minus-style: for removed lines [default: normal auto]
#
# - zero-style: for unchanged lines [default: syntax normal]
#
# - plus-style: for added lines [default: syntax auto]
#
# - minus-emph-style: for emphasized sections of removed lines [default: normal
#   auto]
#
# - minus-non-emph-style: for non-emphasized sections of removed lines that have
#   an emphasized section. Defaults to minus-style [default: auto auto]
#
# - plus-emph-style: for emphasized sections of added lines [default: syntax auto]
#
# - plus-non-emph-style: for non-emphasized sections of added lines that have an
#   emphasized section. Defaults to plus-style [default: auto auto]
#
# - commit-style: for the commit hash line. The style 'omit' can be used to remove
#   the commit hash line from the output [default: raw]
#
# - commit-decoration-style: for the commit hash decoration. The style string
#   should contain one of the special attributes 'box', 'ul' (underline), 'ol'
#   (overline), or the combination 'ul ol' [default: ]
#
# - file-style: for the file section. The style 'omit' can be used to remove the
#   file section from the output [default: blue]
#
# - file-decoration-style: for the file decoration. The style string should
#   contain one of the special attributes 'box', 'ul' (underline), 'ol'
#   (overline), or the combination 'ul ol' [default: blue ul]
#
# - hunk-header-style: for the hunk-header. Special attributes 'file' and
#   'line-number' can be used to include the file path, and number of first hunk
#   line, in the hunk header. The style 'omit' can be used to remove the hunk
#   header section from the output [default: line- number syntax]
#
# - hunk-header-file-style: for the file path part of the hunk-header. The file
#   path will only be displayed if hunk-header-style contains the 'file' special
#   attribute [default: blue]
#
# - hunk-header-line-number-style: for the line number part of the hunk-header.
#   The line number will only be displayed if hunk-header-style contains the
#   'line-number' special attribute [default: blue]
#
# - hunk-header-decoration-style: for the hunk-header decoration. The style string
#   should contain one of the special attributes 'box', 'ul' (underline), 'ol'
#   (overline), or the combination 'ul ol' [default: blue box]
#
# - line-numbers-minus-style: for line numbers in the old (minus) version of the
#   file. See STYLES and LINE NUMBERS sections [default: auto]
#
# - line-numbers-zero-style: for line numbers in unchanged (zero) lines. See
#   STYLES and LINE NUMBERS sections [default: auto]
#
# - line-numbers-plus-style: for line numbers in the new (plus) version of the
#   file. See STYLES and LINE NUMBERS sections [default: auto]
#
# - line-numbers-left-style: for the left column of line numbers. See STYLES and
#   LINE NUMBERS sections [default: auto]
#
# - line-numbers-right-style: for the right column of line numbers. See STYLES and
#   LINE NUMBERS sections [default: auto]
#
# - minus-empty-line-marker-style: Style for removed empty line marker (used only
#   if minus-style has no background color) [default: normal auto]
#
# - plus-empty-line-marker-style: Style for added empty line marker (used only if
#   plus-style has no background color) [default: normal auto]
#
# - whitespace-error-style: Style for whitespace errors. Defaults to
#   color.diff.whitespace if that is set in git config, or else 'magenta reverse'
#   [default: auto auto]
#
# DOC: https://github.com/dandavison/delta#full---help-output

[delta "decorations"]
    whitespace-error-style = magenta reverse
    commit-decoration-style = bold yellow box ul
    file-style = normal
    file-decoration-style = blue ul ol

[merge]
  ff = true

[color]
  ui = auto

[color "branch"]
  current = green bold
  local = green
  remote = cyan dim

# The value for a variable that takes a color is a list of colors (at most two,
# one for foreground and one for background) and attributes (as many as you want),
# separated by spaces.
# The basic colors accepted are normal, black, red, green, yellow, blue, magenta,
# cyan and white. The first color given is the foreground; the second is the
# background. All the basic colors except normal have a bright variant that can be
# specified by prefixing the color with bright, like brightred.
# Colors may also be given as numbers between 0 and 255; these use ANSI 256-color
# mode (but note that not all terminals may support this). If your terminal
# supports it, you may also specify 24-bit RGB values as hex, like #ff0ab3.
# The accepted attributes are bold, dim, ul, blink, reverse, italic, and strike
# (for crossed-out or "strikethrough" letters). The position of any attributes
# with respect to the colors (before, after, or in between), doesn’t matter.
# Specific attributes may be turned off by prefixing them with no or no- (e.g.,
# noreverse, no-ul, etc).
# DOC: https://git-scm.com/docs/git-config#Documentation/git-config.txt-color
#
# color.diff.<slot> - Use customized color for diff colorization. <slot> specifies
# which part of the patch to use the specified color, and is one of context
# (context text - plain is a historical synonym), meta (metainformation), frag
# (hunk header), func (function in hunk header), old (removed lines), new (added
# lines), commit (commit headers), whitespace (highlighting whitespace errors),
# oldMoved (deleted lines), newMoved (added lines), oldMovedDimmed,
# oldMovedAlternative, oldMovedAlternativeDimmed, newMovedDimmed,
# newMovedAlternative newMovedAlternativeDimmed (See the <mode> setting of
# --color-moved in git-diff[1] for details), contextDimmed, oldDimmed, newDimmed,
# contextBold, oldBold, and newBold (see git-range-diff[1] for details).
# DOC: https://git-scm.com/docs/git-config#Documentation/git-config.txt-colordiffltslotgt
#
# SOURCE: 30sep2021 https://stackoverflow.com/a/61993060
# SOURCE: 28jun2021 https://www.git-scm.com/book/en/v2/Customizing-Git-Git-Configuration#_color

[color "diff"]
  meta = yellow
  frag = normal reverse
  func = normal
  context = normal dim
  old = red
  new = green
  whitespace = blue

[log]
  decorate = short
  # Like the default, but designed to be shown alonside %{a,c}r and %{a,c}D:
  # - does not show year and seconds
  # - shows timezone
  # - 0-padded days for column width consistency
  date = format-local:%a %b %d %R %Z
  # Like the default, but padding the days with a leading 0, for column width consistency.
  # date = format-local:%a %b %d %T %Y

[pretty]
  original = %C(yellow)%h%C(green) %ad %C(reset)| %s%C(red)%d %C(blue)[%an]%C(reset)
  graph    = %C(yellow)%h %C(reset)%s %C(blue)[%an]%C(red bold)%d%C(reset)
  hist     = %C(yellow)%H%C(magenta)% (describe)%C(red bold)%d%n%s%n%C(green) %>(14)%ar | %>(31)%aD | %ad %C(white)| %C(blue)authored  by %an <%ae>%n%C(white dim) %>(14)%cr | %>(31)%cD | %cd % | committed by %cn <%ce> | signed %G?% GS%n%n%-b%n%n%-N%n%C(reset)

[push]
  default = upstream

[github "issues"]
  show-labels = true
  show-repo = false
  color = true
  # assignee = none
  assignee = all

[init]
  defaultBranch = main

[fetch]
  throttle-threshold-in-minutes = 60

# To understand the structure of this aliases see https://www.atlassian.com/blog/git/advanced-git-aliases
[alias]

  # Initialise a git repo in the current folder adding all of its contents to an initial commit.
  # SOURCE: http://blog.blindgaenger.net/advanced_git_aliases.html
  this = !git init && git add . && git commit -m \"initial commit\"

  rl = repo list
  ro = repo open
  rc = repo clone

  repo = !"f() { \
    git imp-prevent-inception || exit $?; \
    export CURRENT_ALIAS_NAME='repo'; \
    export REPO_DIR_BASE=~/dev/repos; \
    COMMAND=\"${1}\"; \
    shift; \
    case ${COMMAND} in \
      clone) \
        git imp-repo-clone \"${@}\"; \
        ;; \
      list) \
        git imp-repo-list \"${@}\"; \
        ;; \
      open) \
        git imp-repo-open \"${@}\"; \
        ;; \
      help) \
        git imp-warn-alias \"[open] <repo name pattern>\"; \
        git imp-warn-alias \"clone <ssh url>\"; \
        git imp-warn-alias \"list [<repo name pattern>]\"; \
        ;; \
      '') \
        git imp-error-alias - missing command; \
        f help \
        ;; \
      *) \
        git imp-error-alias - invalid command ${COMMAND}; \
        f help \
        ;; \
    esac; \
  }; f"

  # Clone a repo but get only the current commit instead of the full history. Useful for installing tools.
  shallow-clone = clone --depth=1

  # Short for Add All.
  aa = add .

  # Short for 'git add --patch'. From the doc in 'git add --help': "This
  # effectively runs add --interactive, but bypasses the initial command menu
  # and directly jumps to the patch subcommand."
  ap = add --patch

  unthrottled-fetch = throttled-fetch --bypass-throttling

  throttled-fetch = !"f() { \
    : git fetch ; \
    IS_THROTTLE_IGNORED=false; \
    if [ \"${1}\" = '--bypass-throttling' ]; then \
      IS_THROTTLE_IGNORED=true; \
      shift; \
    fi; \
    THRESHOLD_IN_MINUTES=\"$(git config --get fetch.throttle-threshold-in-minutes || echo 30)\"; \
    CACHE_GIT_DIR=~/.cache/git/fetch; \
    mkdir -p "${CACHE_GIT_DIR}"; \
    REPO_HASH=\"$(echo \"$(pwd) $(git remote get-url --push origin)\" | shasum -a256 | tr -dc '[:alnum:]')\"; \
    TOUCH_FILE=${CACHE_GIT_DIR}/${REPO_HASH}.repo; \
    if $IS_THROTTLE_IGNORED || [ -z \"$(find \"${TOUCH_FILE}\" -mtime -${THRESHOLD_IN_MINUTES}m -print 2>/dev/null)\" ]; then \
      git fetch ${@} && touch \"${TOUCH_FILE}\"; \
    elif [[ \"${*}\" =~ --verbose ]]; then \
      git imp-warn a fetch for this repo was done less than ${THRESHOLD_IN_MINUTES} minutes ago - skipping fetch; \
      git imp-warn \"try 'git unthrottled-fetch' if you want to bypass throttling\"; \
    fi; \
  }; f"

  # Short for Amend (or Add) To Last Commit.
  atlc = !git imp-is-a-commit-possible && git commit --amend -C HEAD

  # Shorthand for 'git commit -m "commit message"' but without the need to quote the commit
  # message, and checking the max commit length.
  cm = !"f() { COMMIT_MESSAGE=\"${*}\"; git imp-check-commit-message-length \"${COMMIT_MESSAGE}\" && git commit -m \"${COMMIT_MESSAGE}\"; }; git imp-is-a-commit-possible && f"

  # Like 'git cam commit message' but simulating the --all commit flag to include in the commit the files
  # that have been modified and deleted. However, new files you have not told Git about are not affected.
  # DOC: https://git-scm.com/docs/git-commit#git-commit---all
  # DOC: https://git-scm.com/docs/git-add#git-add---update
  cam = ! git imp-is-cam-reasonable && git add --update && git cm

  # SOURCE: 27sep2021  https://stackoverflow.com/a/3828861
  fixup = !"f() { COMMIT_TO_FIXUP=${1:-HEAD}; if [[ \"$(git rev-parse --short ${COMMIT_TO_FIXUP})\" == \"$(git rev-parse --short HEAD)\" ]]; then git atlc; else git imp-is-a-commit-possible && git commit --fixup=${COMMIT_TO_FIXUP} && git rebase --interactive --autosquash ${COMMIT_TO_FIXUP}~1; fi; }; f"

  # Like 'git cam commit message' but automatically pushing to origin after commit.
  camp = !"f() { git cam \"${*}\" && git push; }; f"

  # Like 'git camp commit message' but without adding anything else, i.e. using git cm instead of git cam.
  cmp = !"f() { git cm \"${*}\" && git push; }; f"
  
  # Undoes the last commit printing contextual information.
  uncommit = ! git h -1 && git reset HEAD^ && git reflog -1 && git h -1

  # This is an alias to 'git checkout' but without any arguments it will list all local branches
  # to choose the one we want to switch to (useful in systems without tab-autocompletion).
  co = !"f() { : git checkout ; git imp-prevent-inception || exit $?; if [ -n \"${1}\" ]; then git checkout \"${@}\"; exit; fi; b=(); c=0; while read -r l; do (( c++ )); if [ -n \"${l}\" ]; then b[${c}]="$l"; echo \"$c: $l\"; else git imp-error \"there are no other branches beyond '$(git imp-current-branch-name)' that can be checked out here\"; git imp-warn \"if you are looking for a branch, try 'git br':\"; git br; exit 1; fi; done <<< \"$(git branch | grep -v \"*\" | grep -v \"+\")\"; read -p \"Switch to branch number [default: ${b[1]}]: \" bn; bn=\"$(echo ${bn:-1} | sed 's/.*[^0-9].*//g')\"; if [ -n \"${b[${bn}]}\" ]; then git checkout ${b[${bn}]}; else git imp-error \"invalid option\"; fi; }; f"

  # Similar to 'git co' but for 'git merge'.
  me = !"f() { : git merge ; if [ -n \"${1}\" ]; then git merge \"${@}\"; exit; fi; b=(); c=0; while read -r l; do (( c++ )); if [ -n \"${l}\" ]; then b[${c}]="$l"; echo \"$c: $l\"; else echo \"There are no other branches beyond '$(git imp-current-branch-name)'.\"; exit; fi; done <<< \"$(git branch | grep -v \"*\")\"; read -p \"Branch number to merge into current branch '$(git imp-current-branch-name)' [default: ${b[1]}]: \" bn; bn=\"$(echo ${bn:-1} | sed 's/.*[^0-9].*//g')\"; if [ -n \"${b[${bn}]}\" ]; then git merge ${b[${bn}]}; else git imp-error \"invalid option\"; fi; }; f"

  # The contrary of 'git add' to remove files from the stage to be committed.
  unstage = reset HEAD --

  # Show a compact and easy to ready version of 'git status'.
  # NOTE: The short version with the same options (to use it e.g. directly in the terminal)
  # is 'git status -sb'.
  # DOC: https://git-scm.com/docs/git-status#git-status--s
  st = !git st-upstream-remote && git status --short --branch && git imp-check-latest-pushed-commit-for-current-branch
  st-upstream-remote = !"f() {\
    git remote | grep ^origin$ 1>/dev/null || return 0; \
    git remote | grep ^upstream$ 1>/dev/null || return 0; \
    BRANCH_NAME=${1:-$(git imp-current-branch-name)}; \
    ORIGIN_MAIN_BRANCH_NAME=origin/${BRANCH_NAME}; \
    UPSTREAM_MAIN_BRANCH_NAME=upstream/${BRANCH_NAME}; \
    git imp-check-if-branch-exists ${UPSTREAM_MAIN_BRANCH_NAME} || return 0; \
    [ \"$(git imp-current-branch-name)\" = ${BRANCH_NAME} ] || printf \"$(tput dim)\"; \
    printf \"## $(tput setaf 1)${ORIGIN_MAIN_BRANCH_NAME}$(tput sgr0)...$(tput setaf 5)${UPSTREAM_MAIN_BRANCH_NAME}$(tput sgr0)\"; \
    NUMBER_OF_NEW_COMMITS_IN_ORIGIN=$(git rev-list --count ${UPSTREAM_MAIN_BRANCH_NAME}..${ORIGIN_MAIN_BRANCH_NAME}); \
    NUMBER_OF_NEW_COMMITS_IN_UPSTREAM=$(git rev-list --count ${ORIGIN_MAIN_BRANCH_NAME}..${UPSTREAM_MAIN_BRANCH_NAME}); \
    case \"${NUMBER_OF_NEW_COMMITS_IN_ORIGIN}-${NUMBER_OF_NEW_COMMITS_IN_UPSTREAM}\" in \
      0-0) \
        echo; \
        ;; \
      *-0) \
        echo \" [ahead $(tput setaf 1)${NUMBER_OF_NEW_COMMITS_IN_ORIGIN}$(tput sgr0)]\";\
        ;; \
      0-*) \
        echo \" [behind $(tput setaf 5)${NUMBER_OF_NEW_COMMITS_IN_UPSTREAM}$(tput sgr0)]\";\
        ;; \
      *-*) \
        echo \" [ahead $(tput setaf 1)${NUMBER_OF_NEW_COMMITS_IN_ORIGIN}$(tput sgr0), behind $(tput setaf 5)${NUMBER_OF_NEW_COMMITS_IN_UPSTREAM}$(tput sgr0)]\";\
        ;; \
    esac; \
  }; f"
  st-upstream-remote-main = !git st-upstream-remote "$(git imp-main-branch-name)"

  # This is an alias to 'git branch' but without any arguments it will list a detailed list of the branches.
  br = !"f() { : git branch ; if [ -n \"${1}\" ]; then git branch \"${@}\"; else git br-details \"${@}\"; fi; }; f"
  # DOC: https://git-scm.com/docs/git-for-each-ref
  br-details  = !PREV_BRANCH="$(git rev-list --quiet @{-1} 2>/dev/null && git rev-parse --symbolic-full-name @{-1} || echo '')" && MAX_BRANCH_NAME_LENGTH=$(git imp-get-max-branch-name-length include-remote-branches) && BRANCH_NAME_COL_WIDTH=$((( MAX_BRANCH_NAME_LENGTH + 2 ))) && git for-each-ref --sort=-committerdate --format='%(if:equals=refs/remotes/origin)%(refname:rstrip=-3)%(then)%(color:cyan)R %(align:'${BRANCH_NAME_COL_WIDTH}',left)%(refname:lstrip=2)%(end) %(align:22,left)remote origin branch%(end)%(else)%(if:equals=refs/remotes/upstream)%(refname:rstrip=-3)%(then)%(color:magenta)R %(align:'${BRANCH_NAME_COL_WIDTH}',left)%(refname:lstrip=2)%(end) %(align:22,left)remote upstream branch%(end)%(else)%(if:equals=refs/remotes)%(refname:rstrip=-2)%(then)%(color:blue)R %(align:'${BRANCH_NAME_COL_WIDTH}',left)%(refname:lstrip=2)%(end) %(align:22,left)remote branch%(end)%(else)%(if)%(HEAD)%(then)%(color:bold)%(else)%(end)%(color:green)%(if)%(HEAD)%(then)* %(else)%(if)%(worktreepath)%(then)+ %(else)%(if:equals='"${PREV_BRANCH}"')%(refname)%(then)- %(else)  %(end)%(end)%(end)%(align:'${BRANCH_NAME_COL_WIDTH}',left)%(refname:short)%(end) %(align:25,left)%(if)%(upstream)%(then)%(if)%(upstream:track)%(then)%(if:equals=[gone])%(upstream:track)%(then)%(color:red)published gone%(else)%(color:yellow)published, %(upstream:track,nobracket)%(end)%(else)%(color:green)published, in sync%(end)%(else)%(color:yellow)%(upstream)not published%(end)%(end)%(end)%(end)%(end)%(color:white) * %(color:yellow)%(objectname:short) %(color:green)%(align:16,right)%(committerdate:human)%(end)%(color:white) | %(align:70,left)%(contents:subject)%(end) %(color:blue)[%(committername)]%(if)%(worktreepath)%(then)%(if)%(HEAD)%(then)%(else)%(color:reset)%(color:white dim)%0a  ╚═> checked out at %(worktreepath)%(end)%(end)%(color:reset)' refs/heads/
  bra = br-details refs/remotes
  braa = !echo "$ git branch -avv" && git branch -avv && echo && echo "$ git remote show origin" && git remote show origin

  # Publish the current branch to the origin remote and open the PR/MR URL if
  # found.
  # NOTE: The trailing integers in 'trap "rm ${TMP_LOG_FILE}" 0 2 3 15' are the
  # signals upon which to run the first argument. 0: exit shell, 2: Interrupt,
  # 3: Quit, 15: Terminate.
  # SOURCE: 16oct2021 https://unix.stackexchange.com/a/181939
  br-publish = !"f() { \
      export CURRENT_ALIAS_NAME=br-publish; \
      if [ $# -ne 0 ]; then \
        git imp-error-alias does not accept arguments; \
        git imp-warn-alias pushes the current branch to origin and sets the new \
          remote branch as upstream. If the response from the server includes \
          URL to open a PR, it will be open in your default browser as well.; \
        exit 1; \
      fi; \
      git imp-check-clean-tree || exit $?; \
      git throttled-fetch --all; \
      UPSTREAM_BRANCH_NAME=$(git imp-upstream-branch-name); \
      if [ -n \"${UPSTREAM_BRANCH_NAME}\" ]; then \
        git imp-error \"'$(git imp-current-branch-name)' branch is already published to its upstream '${UPSTREAM_BRANCH_NAME}'\"; \
        git imp-warn \"try 'git push' instead\"; \
        exit 1; \
      fi; \
      if ! git imp-is-current-branch-up-to-date-with-upstream-main; then \
        git imp-error \"'$(git imp-current-branch-name)' branch is not up to date with '$(git imp-upstream-main-branch-name)'\"; \
        git imp-warn \"try 'git rebase $(git imp-upstream-main-branch-name)' before publishing\"; \
        exit 1; \
      fi; \
      NEW_COMMITS_COUNT=$(git rev-list --count $(git imp-main-branch-name)..$(git imp-current-branch-name); exit $?; ) || exit $?; \
      if (( $NEW_COMMITS_COUNT < 1 )); then \
        git imp-error \"no new commits on top of '$(git imp-main-branch-name)' branch - nothing to publish yet\"; \
        exit 1; \
      fi; \
      TMP_LOG_FILE=$(mktemp /tmp/git_push.log.XXXXXX) || exit 1; \
      trap \"rm ${TMP_LOG_FILE}\" 0 2 3 15; \
      git push -u origin $(git imp-current-branch-name) 2>&1 | tee ${TMP_LOG_FILE} ; \
      CONTRIBUTION_REQUEST_URL=\"$(grep -o \"https://\\S\\+\\(pull\\|merge_requests\\)/new\\S*\\(/\\|=\\)$(git imp-current-branch-name)\" ${TMP_LOG_FILE})\"; \
      [ -z ${CONTRIBUTION_REQUEST_URL} ] && exit; \
      CONTRIBUTION_REQUEST_TYPE='pull'; \
      [[ ${CONTRIBUTION_REQUEST_URL} =~ merge_request ]] && CONTRIBUTION_REQUEST_TYPE='merge'; \
      CONTRIBUTION_REQUEST_URL_DOMAIN=$(echo ${CONTRIBUTION_REQUEST_URL} | grep -o '\\w\\+\\.\\w\\{2,3\\}'); \
      if open ${CONTRIBUTION_REQUEST_URL}; then \
        git imp-success \"the URL to create a ${CONTRIBUTION_REQUEST_TYPE} request\" \
                        \"for '$(git imp-current-branch-name)' on ${CONTRIBUTION_REQUEST_URL_DOMAIN}\" \
                        \"has been open\"; \
      else \
        git imp-error-alias is unable to automatically open the URL to ${CONTRIBUTION_REQUEST_TYPE} request; \
        git imp-warn the ${CONTRIBUTION_REQUEST_TYPE} request URL is ${CONTRIBUTION_REQUEST_URL}; \
      fi; \
    }; f"

  # Delete the branches that have been merged to the main branch.
  # SOURCE: https://www.atlassian.com/blog/git/advanced-git-aliases
  # DOC: https://git-scm.com/docs/git-branch#git-branch---mergedltcommitgt
  br-prune-merged = !"MAIN_BRANCH=\"$(git imp-main-branch-name)\" && git imp-check-clean-tree && git checkout ${MAIN_BRANCH} && git branch --merged ${MAIN_BRANCH} | grep -v ${MAIN_BRANCH} | xargs $( [ $(uname) == 'Linux' ] && echo '--no-run-if-empty' ) git branch -dvv;"
  # Delete the branches that have been deleted from remote.
  br-prune-gone   = !"MAIN_BRANCH=\"$(git imp-main-branch-name)\" && git imp-check-clean-tree && git checkout ${MAIN_BRANCH} && git remote -v prune origin && git branch -vv | grep ': gone]' | awk '{print $1}' | xargs $( [ $(uname) == 'Linux' ] && echo '--no-run-if-empty' ) git branch -dvv"

  # Work with working trees.
  # DOC https://git-scm.com/docs/git-worktree
  wt = worktree
  wtl = worktree list
  wt-br = !"f() { : git branch ; case $# in 0) git imp-error 'missing branch name';; 1) git worktree add .linked-worktrees/${1#origin/} ${1#origin/};; *) git imp-error 'only one are argument accepted: branch name';; esac; }; f"
  wtc = !"f() { git imp-prevent-inception || exit $?; export CURRENT_ALIAS_NAME='wtc'; if [ -n \"${1}\" ]; then git imp-error 'no arguments accepted'; exit 1; fi; wts=(); i=0; while read -r wt; do (( i++ )); if [ -n \"${wt}\" ]; then wts[${i}]="$wt"; echo \"$i: $wt\"; else echo 'There are no linked working trees.'; exit; fi; done <<< \"$(git worktree list | grep -v \"^$(pwd) \")\"; read -p \"Switch to worktree number [default: 1]: \" choice; if [ -n \"${wts[${choice:=1}]}\" ]; then shopt -s extglob; cd \"${wts[${choice}]%%+( )[a-z0-9][a-z0-9][a-z0-9][a-z0-9][a-z0-9][a-z0-9][a-z0-9] \\[*}\"; shopt -u extglob; RUNNING_INSIDE_SUB_SHELL=true $SHELL; else git imp-error \"invalid option\"; fi; }; f"

# TODO: Create command similar to 'git hotfix' for 'git feature'. Differences:
#     - s/hotfix/feature/gi in messages and paths
#     - do not require to branch off a branch existing in origin
#     - do not require connection with origin, i.e. do not fetch before starting a new feature working tree
#     - do not automatically push on exit when there are new commits, but ask instead
#     - do not default to current branch, instead:
#          - without arguments it lists all current open features and lets you pick which one to switch to
#          - with one argument it partial matches on the list of open features and
#            if no match is found, asks to create a new feature workspace based off that name

  hotfix = !"f() { \
    : git branch ; \
    git imp-prevent-inception || exit $?; \
    export CURRENT_ALIAS_NAME='hotfix'; \
    HOTFIX_EXPLANATION=\"$(git imp-underline git hotfix) will automatically create\"; \
    HOTFIX_EXPLANATION+=\" a hotfix workspace for the branch you are on and put\"; \
    HOTFIX_EXPLANATION+=\" you in it so that you can start working on\"; \
    HOTFIX_EXPLANATION+=\" the hotfix immediately, even if you have unpushed commits\"; \
    HOTFIX_EXPLANATION+=\" or uncommitted modifications in your original branch. Optionally you\"; \
    HOTFIX_EXPLANATION+=\" can pass the branch you want to hotfix as argument. When you are done\"; \
    HOTFIX_EXPLANATION+=\" with the hotfix and committed the changes, you can simply\"; \
    HOTFIX_EXPLANATION+=\" exit the workspace (i.e. the sub-shell) with $(git imp-underline CTRL-D)\"; \
    HOTFIX_EXPLANATION+=\" and the changes will be automatically pushed to origin.\"; \
    HOTFIX_EXPLANATION+=\" If you exit the workspace without doing\"; \
    HOTFIX_EXPLANATION+=\" any modifications, the local hotfix workspace will be cleaned\"; \
    HOTFIX_EXPLANATION+=\" up, i.e. the working tree and new branch will be deleted.\"; \
    case $# in \
      0) \
        echo; \
        git imp-echo \"${HOTFIX_EXPLANATION}\"; \
        echo; \
        read -n 1 -s -r -p \"Press any key to continue or CTRL-C to abort...\"; \
        printf \"$(tput el1)\\r\"; \
        ;; \
      1) \
        : \
        ;; \
      *) \
        git imp-error $(git imp-underline git hotfix) only takes one optional argument; \
        echo; \
        git imp-echo \"${HOTFIX_EXPLANATION}\"; \
        echo; \
        return 1; \
        ;; \
    esac; \
    git sync || exit 1 ; \
    ORIGINAL_PWD=\"$(pwd)\"; \
    BRANCH_TO_HOTFIX_FROM=\"${1:-$(git imp-current-branch-name)}\"; \
    BRANCH_TO_HOTFIX_FROM=\"$(git rev-parse --abbrev-ref  \"origin/${BRANCH_TO_HOTFIX_FROM#origin/}\")\"; \
    if ! git show-ref --verify --quiet \"refs/remotes/${BRANCH_TO_HOTFIX_FROM}\"; then \
      git imp-error \"you can only hotfix a branch in origin\"; \
      exit 1; \
    fi; \
    HOTFIX_BRANCH_NAME_PREFIX=\"$(git imp-sanitize-string-for-branch-name \"$(git config user.name)\")-hotfix-on\"; \
    POTENTIALLY_EXISTING_WORKTREE_DIR=\"${BRANCH_TO_HOTFIX_FROM/#origin\\//.linked-worktrees/hotfixes/}\"; \
    IS_ORPHAN_HOTFIX_BRANCH=\"false\"; \
    if git branch -vv | grep ${POTENTIALLY_EXISTING_WORKTREE_DIR}\\) 1>/dev/null 2>&1; then \
      COMMIT_TO_HOTFIX_FROM=\"${BRANCH_TO_HOTFIX_FROM##*-}\"; \
      HOTFIX_BRANCH_NAME=\"${BRANCH_TO_HOTFIX_FROM#origin/}\"; \
    elif [[ \"${BRANCH_TO_HOTFIX_FROM}\" =~ ^origin/${HOTFIX_BRANCH_NAME_PREFIX} ]]; then \
      IS_ORPHAN_HOTFIX_BRANCH=\"true\"; \
      COMMIT_TO_HOTFIX_FROM=\"${BRANCH_TO_HOTFIX_FROM##*-}\"; \
      HOTFIX_BRANCH_NAME=\"${BRANCH_TO_HOTFIX_FROM#origin/}\"; \
    else \
      COMMIT_TO_HOTFIX_FROM=\"$(git rev-parse --short \"${BRANCH_TO_HOTFIX_FROM}\")\"; \
      HOTFIX_BRANCH_NAME=\"${HOTFIX_BRANCH_NAME_PREFIX}-${BRANCH_TO_HOTFIX_FROM#origin/}-${COMMIT_TO_HOTFIX_FROM}\"; \
    fi; \
    LINKED_WORKTREE_DIR=\".linked-worktrees/hotfixes/${HOTFIX_BRANCH_NAME}\"; \
    if $IS_ORPHAN_HOTFIX_BRANCH; then \
      git imp-warn 'this looks like an orphan hotfix branch - recreating working tree'; \
      git worktree add \"${LINKED_WORKTREE_DIR}\" || exit $?; \
    elif [ -d \"${LINKED_WORKTREE_DIR}\" ]; then \
      git imp-warn 'working tree for this hotfix already exists'; \
    else \
      git imp-warn 'creating a new working tree'; \
      git worktree add \"${LINKED_WORKTREE_DIR}\" -b \"${HOTFIX_BRANCH_NAME}\" --no-track \"${BRANCH_TO_HOTFIX_FROM}\" || exit $?; \
    fi; \
    cd \"${LINKED_WORKTREE_DIR}\"; \
    if $(git imp-check-if-branch-exists-in-origin ${HOTFIX_BRANCH_NAME}); then \
      git branch --set-upstream-to=\"origin/${HOTFIX_BRANCH_NAME}\" \"${HOTFIX_BRANCH_NAME}\"; \
      git merge --ff-only \"origin/${HOTFIX_BRANCH_NAME}\" || \
        git imp-warn origin has some newer commits that cannot be fast-forwarded - consider git pull --rebase; \
    fi; \
    git imp-echo \"When done, $(git imp-underline exit this sub-shell with CTRL-D). If you have added any\" \
                 \"commits, the new branch ${HOTFIX_BRANCH_NAME} will be then automatically pushed\" \
                 \"to origin. If you exit without any modifications (i.e. new commits or modified\" \
                 \"files) the local hotfix working tree will be automatically cleaned up.\" \
                 \"Otherwise, it will be kept until you remove it with 'git worktree remove'.\" \
                 \"You are now in the hotfix workspace at following commit:\"; \
    git h -1; \
    RUNNING_INSIDE_SUB_SHELL=true $SHELL; \
    if ! git imp-is-tree-clean; then \
      git imp-warn \"there are uncommitted changes - local hotfix files will be kept\"; \
      git imp-warn \"issue the same 'git hotfix' command to continue where you left\"; \
      exit; \
    fi; \
    cd \"${ORIGINAL_PWD}\"; \
    if [ \"$(git rev-parse --short \"${HOTFIX_BRANCH_NAME}\")\" = \"${COMMIT_TO_HOTFIX_FROM}\" ]; then \
      git imp-warn \"No new commits added. Cleaning up local hotfix files...\"; \
      IS_FETCH_NEEDED_BEFORE_PRUNE=false git hotfix-prune \"${HOTFIX_BRANCH_NAME}\" || exit $?; \
    elif [ \"$(git rev-parse --short \"${HOTFIX_BRANCH_NAME}\")\" = \"$(git rev-parse --short \"origin/${HOTFIX_BRANCH_NAME}\" 2>/dev/null || echo 0)\" ]; then \
      git imp-warn \"${HOTFIX_BRANCH_NAME} already up to date with origin. Nothing to push.\"; \
      git imp-warn \"to remove the local hotfix workspace run 'git hotfix-prune ${HOTFIX_BRANCH_NAME}'\"; \
    else \
      NEW_COMMITS_COUNT=$(git rev-list --count origin/${HOTFIX_BRANCH_NAME}..${HOTFIX_BRANCH_NAME} 2>/dev/null || echo 0); \
      if (( $NEW_COMMITS_COUNT == 0 )); then \
        NEW_COMMITS_COUNT=$(git rev-list --count ${COMMIT_TO_HOTFIX_FROM}..${HOTFIX_BRANCH_NAME}); \
      fi; \
      git imp-success \"${NEW_COMMITS_COUNT} commit(s) added. Pushing the branch ${HOTFIX_BRANCH_NAME} to origin...\"; \
      git push --set-upstream origin \"${HOTFIX_BRANCH_NAME}\"; \
      git imp-warn \"to remove the local hotfix workspace run 'git hotfix-prune ${HOTFIX_BRANCH_NAME}'\"; \
    fi; \
  }; f"
  hotfix-prune = !"f() { \
    : git branch ; \
    git imp-prevent-inception || exit $?; \
    if (($# != 1)); then \
      git imp-error $(git imp-underline git hotfix-prune) needs one argument; \
      return 1; \
    fi; \
    if ${IS_FETCH_NEEDED_BEFORE_PRUNE:-true}; then \
      git unthrottled-fetch --all || exit 1 ; \
    fi; \
    HOTFIX_TO_PRUNE=\"${1:?Missing hotfix to prune}\"; \
    HOTFIX_BRANCH_NAME_PREFIX=\"$(git imp-sanitize-string-for-branch-name \"$(git config user.name)\")-hotfix-on\"; \
    HOTFIX_BRANCH_NAME_SUFFIX='-.*-[[:alnum:]][[:alnum:]][[:alnum:]][[:alnum:]][[:alnum:]][[:alnum:]][[:alnum:]]'; \
    if [[ ! \"${HOTFIX_TO_PRUNE}\" =~ ^${HOTFIX_BRANCH_NAME_PREFIX}${HOTFIX_BRANCH_NAME_SUFFIX}$ ]]; then \
      git imp-error 'only local hotfix workspaces created by you can be pruned'; \
      return 1; \
    fi; \
    LINKED_WORKTREE_DIR=\".linked-worktrees/hotfixes/${HOTFIX_TO_PRUNE}\"; \
    if [ -d \"${LINKED_WORKTREE_DIR}\" ]; then \
      if git worktree remove \"${LINKED_WORKTREE_DIR}\"; then \
        git imp-echo \"Removed working tree '${LINKED_WORKTREE_DIR}'.\"; \
      else \
        exit 1; \
      fi; \
    else \
      git imp-warn \"working tree ${LINKED_WORKTREE_DIR} not found\"; \
    fi; \
    if git show-ref --verify --quiet \"refs/remotes/origin/${HOTFIX_TO_PRUNE}\"; then \
      git imp-warn \"the remote branch origin/${HOTFIX_TO_PRUNE} will not be deleted automatically\"; \
      git imp-warn \"to delete the remote branch run 'git push origin --delete ${HOTFIX_TO_PRUNE}'\"; \
    fi; \
    git branch -d \"${HOTFIX_TO_PRUNE}\" || exit $?; \
  }; f"

  # Fetch all remotes and print the state of all branches. This command does not modify anything locally.
  sync = !git unthrottled-fetch --progress --verbose --all --prune && echo && git bra
  s = sync
  # Like 'git sync' but switching to the main branch, updating it and removing all local branches that have been merged to the main branch.
  # DOC: https://git-scm.com/docs/git-pull#git-pull---ff-only
  sync-hard = !"MAIN_BRANCH=\"$(git imp-main-branch-name)\" && git imp-check-clean-tree && git sync && git checkout ${MAIN_BRANCH} && git pull --ff-only --verbose && git br-prune-gone && git gc && git bra"
  sh = sync-hard

  sync-with-forked-repo = !git checkout master && git pull upstream master && git push

  viewh = -c pager.show=delta -c delta.side-by-side=false show
  viewv = -c pager.show=delta -c delta.side-by-side=true  show

  # 'git show' using the delta aliases defined above, automatically choosing
  # between horizontal and side-by-side modes depending on max line length in
  # diff.
  view  = ! git imp-is-output-too-wide-for-terminal-for-command show ${@} && git viewh ${@} || git viewv

  difft = difftool

  # Diffs using delta as setup in pager.diff in vertical mode (i.e.
  # side-by-side) for easy comparing changes in short lines.
  dv   = -c delta.side-by-side=true diff
  dvc  = dv --cached

  # Diffs using delta as setup in pager.diff in horizontal mode to allow
  # comparing changes in long lines.
  dh   = -c delta.side-by-side=false diff
  dhc  = dh --cached

  # Diffs using the delta aliases defined above, automatically choosing between
  # horizontal and side-by-side modes depending on max line length in diff.
  d    = !": git diff ; git imp-is-output-too-wide-for-terminal-for-command diff ${@} && git dh ${@} || git dv"
  dc   = d --cached

  # Diffs using the 'less' as pager instead of 'delta'.
  dp   = ! ": git diff ; GIT_PAGER='less -FRXK' git diff"
  dpc  = dp --cached
  dpw  = dp --word-diff=color
  dpwc = dpw --cached

  # Stats about the files changed. These aliases are not affected by the pager.
  ds   = diff --stat --raw
  dsc  = ds --cached

  wip = !"f() { git add -A && git commit --no-gpg-sign -am \"[WIP] ${*}\"; }; f"
  unwip = !"f() { LAST_COMMIT_MESSAGE=\"$(git log -1 --pretty=tformat:%s)\"; [ \"${LAST_COMMIT_MESSAGE:0:5}\" == \"[WIP]\" ] && ( echo \"Undoing last WIP commit: ${LAST_COMMIT_MESSAGE}\" && git reset HEAD^ -- && echo \"Now at:\" && git log -1 --oneline ) || ( echo \"The last commit is not a [WIP] commit! Nothing to do.\"; git log -1 --oneline ) }; f"

  ## Aliases related to the commit history (git log)
  # They include more details such as a graphical representation of the history and the branches
  # (i.e. --graph), the author of the commit and the branch and tag names.
  # DOC: https://git-scm.com/docs/git-log
  #
  # NOTE: If the output is not paginated properly check the documentation for
  # 'core.pager' and 'pager.<cmd>' settings. The order of preference for the
  # pager is the $GIT_PAGER environment variable, then core.pager configuration,
  # then $PAGER, and then the default chosen at compile time (usually less).
  # DOC: https://mirrors.edge.kernel.org/pub/software/scm/git/docs/git-config.html

  # Unlimited number of commits in the current branch, including commit body and
  # notes, if present.
  hist     = log --pretty=hist
  # Like 'git hist' but shows the commit graph.
  histg    = hist --graph
  # Like 'git hist' but shows the commit graph and commits for all branches.
  hista    = histg --all

  # Compact version of the history with less information than 'git hist{,a,g}'
  # in one line, vertically aligned and truncated to terminal width.
  his      = !git log --date=human --pretty=tformat:'%C(yellow)%h%C(green) %>(16)%ad %C(reset)| %<(70)%s %C(blue)[%an] %C(dim)%G?%C(reset)%C(red bold)%<|('$(tput cols)',trunc)%d%C(reset)'
  # Like 'git his' but shows the commit graph.
  hisg     = his --graph
  # Like 'git his' but shows the commit graph and commits for all branches.
  hisa     = hisg --all

  # Shorthand to 'git his' all commits in the current branch not yet pushed to
  # origin or the last 5 commits, whichever is bigger. Useful to check the
  # current state of the branch.
  # DOC: https://git-scm.com/docs/git-log#git-log---max-countltnumbergt
  h       = !git his --max-count=$(c=$(git rev-list --count $(git imp-upstream-branch-name)..HEAD) && ((c>4)) && echo $((c + 1)) || echo 5)

  # Like 'git h' but shows the commit graph.
  hg      = h --graph
  # Like 'git h' but shows the commit graph and commits for all branches.
  ha      = hg --all

  # Like 'git h' but shows all commits in the current branch since branching the
  # main branch.
  hm      = !git his --max-count=$(c=$(git rev-list --count $(git imp-main-branch-name)..HEAD) && echo $((c + 1)))

  # Display detailed information for all commits in all branches like 'git
  # hista' but doing a 'git sync' before to make sure that the command
  # reports the last state in the remotes.
  # NOTE: ': git log ;' notation allows the shell to know from which command the
  # tab-autocompletion should be used.
  # DOC: https://git-scm.com/docs/git-log#git-log---all
  history = ! ": git log ; git sync; echo; git log --graph --all --pretty=hist"

  hista-graph = hista --pretty=graph
  # Like 'git hista-graph' but truncated to terminal width.
  g = !git hista --pretty=tformat:'%C(yellow)%h %C(reset)%s %C(blue)[%an]%C(red bold)%<|('$(tput cols)',trunc)%d%C(reset)'

  # Like 'git hist' but including a summary of how files were changed in each
  # commit.
  # DOC: https://git-scm.com/docs/git-log#git-log---raw
  # DOC: https://git-scm.com/docs/git-log#git-log---shortstat
  hs      = hist --graph --pretty=hist --shortstat --raw

  # Like 'git hs' but including a the full commit diff in each commit.
  # DOC: https://git-scm.com/docs/git-log#git-log---patch
  hdiff   = h --graph --pretty=hist --patch

  # Like 'git hdiff' but showing a word diff instead of a line diff.
  # DOC: https://git-scm.com/docs/git-log#git-log---word-diffltmodegt
  hd      = hdiff --word-diff=color

  commit-info = log --pretty=hist --stat -1
  ci = commit-info

  commit-info-and-diff = commit-info --patch
  cid = commit-info-and-diff

  # The following three aliases are shorthands for 'hs', 'hdiff' and 'hd' but
  # showing only the very last commit.
  # NOTE: '-1' is a shorthand for '--max-count 1'
  lastcommitd     = ! ": git log ; git hd -1"
  lastcommitdiff  = ! ": git log ; git hdiff -1"
  lastcommitstat  = ! ": git log ; git hs -1"
  
  # Show the commit hash of the corresponding commit-ish. E.g. git sha1 HEAD
  # SOURCE: 23sep2021 https://stackoverflow.com/a/949391
  sha1 = rev-parse --verify
  sha1-short = sha1 --short

  # Display a list of all unique author/committer combinations.
  users       = ! "git log --format='commit(s) authored by %an <%ae> and committed by %cn <%ce>' --all | sort | uniq -c | sort -nr"
  # Display a list of all unique authors.
  authors     = ! "git log --format='commit(s) authored by %an <%ae>' --all | sort | uniq -c | sort -nr"
  # Display a list of all unique committers.
  committers  = ! "git log --format='commit(s) committed by %cn <%ce>' --all | sort | uniq -c | sort -nr"


  # Show only the commits that have NOT been merged into the main branch.
  # DOC: https://git-scm.com/docs/git-log#git-log---cherry
  unmerged = ! ": git log ; MAIN_BRANCH=\"$(git imp-main-branch-name)\" && git history --cherry ${MAIN_BRANCH}..HEAD"
  tags = log --pretty=tformat:\"%C(yellow)%h%C(green) %ad %C(red)%d\" --date=relative --simplify-by-decoration --branches --all

  type = cat-file -t
  dump = cat-file -p
  alias = config --get-regexp alias

  # Forget about a tracked file and do not consider it changed thus not
  # including it in the commits. This is useful sometimes to change some
  # configuration files to be used in the local dev environment.
  # DOC: https://www.git-scm.com/docs/git-update-index#git-update-index---no-skip-worktree
  # DOC: https://www.git-scm.com/docs/git-update-index#_skip_worktree_bit
  # SOURCE: https://stackoverflow.com/a/13631525
  # SOURCE: https://fallengamer.livejournal.com/93321.html
  forget = update-index --skip-worktree
  unforget = update-index --no-skip-worktree
  forgotten = !git ls-files -v | grep ^S

  # The 'forget' command above does not remove the file from the repo. To
  # completely stop including a file in a repo (but keep local file), use
  # 'simpleuntrack' and add it to .gitignore configuration. Alternatively,
  # 'untrack' will do both automatically.
  simpleuntrack = rm --cached
  untrack = !"f() { if [ -z \"${1}\" ]; then echo git untrack: You must specify a file.; exit 0; fi; if [ $(find . -path \"*${1}\" | wc -l) == 0 ]; then echo git untrack: ${1}: No such file.; exit 1; fi; if [ $(find . -path \"*${1}\" | wc -l) != 1 ]; then echo git untrack: Try to untrack the file from the root repo dir: $(pwd); exit 1; fi; file=$(find . -path "*$1" | head -1); echo Removing $file from repo but keeping local file... && git rm --cached $file && echo Adding $file to $(pwd)/.gitignore && echo $file >> .gitignore; }; f"

  # List all ignored files detailing the corresponding ignore rule and the file
  # where the ignore rule is defined.
  # DOC: https://www.git-scm.com/docs/git-check-ignore
  ignored = !git check-ignore -v **/*

  trace = !GIT_TRACE=1 git
  debug = trace
  t = trace

  # Append empty new line if output of command is not empty.
  spaced-after = !"f() { \
    TMP_LOG_FILE=$(mktemp /tmp/git_spaced.log.XXXXXX) || exit 1; \
    trap \"rm ${TMP_LOG_FILE}\" 0 2 3 15; \
    git -c color.ui=always ${*:?Missing command} | tee ${TMP_LOG_FILE}; \
    RES=$?; \
    [ -s ${TMP_LOG_FILE} ] && echo; \
    return $RES; \
  }; f"

  imp-get-own-and-repo = !"f() { OWN_AND_REPO=\"$(git config --get remote.origin.url | sed \"s|.*[/:]\\(.*/.*\\)\\.git|\\1|\")\"; [ -n \"${OWN_AND_REPO}\" ] && echo \"${OWN_AND_REPO}\" || git imp-error \"Remote origin url not found.\"; }; f"

  web = !"f() { \
    : git pull ; \
    TARGET_REMOTE=\"${1:-origin}\"; \
    OBJECT_NAME=\"${2:-$(git imp-current-branch-name)}\"; \
    OBJECT_NAME=\"${OBJECT_NAME#${TARGET_REMOTE}/}\"; \
    REMOTE_URL=\"$(git remote get-url --push ${TARGET_REMOTE}; exit $?)\" || exit $?; \
    BASE_URL=\"https://$(echo \"${REMOTE_URL}\" | sed -e 's/^git@//; s/.git$//; s/:/\\//')\"; \
    if [ \"${OBJECT_NAME}\" = \"$(git imp-main-branch-name)\" ]; then \
      git imp-warn \"opening '${TARGET_REMOTE}' repository root webpage\"; \
    elif ! git imp-check-if-branch-exists \"${TARGET_REMOTE}/${OBJECT_NAME}\"; then \
      git imp-warn \"opening '${TARGET_REMOTE}' repository root webpage since '${OBJECT_NAME}' does not exit in '${TARGET_REMOTE}'\"; \
    else \
      git imp-warn \"opening '${TARGET_REMOTE}' repository webpage for branch '${OBJECT_NAME}'\"; \
      case \"${BASE_URL}\" in \
        https://gitlab.com/*) \
          BASE_URL+='/-'; \
          ;; \
      esac; \
      BASE_URL+=\"/tree/${OBJECT_NAME}\"; \
    fi; \
    if open \"${BASE_URL}\"; then \
      git imp-success \"${BASE_URL} opened\"; \
    else \
      git imp-error \"unable to open ${BASE_URL}\"; \
    fi; \
  }; f"

  todo = !" \
    init() { \
      [ -f ${TODO_FILE} ] && return; \
      echo \"# This is a todo file inteded to be used manually or with 'git todo'.\" >> ${TODO_FILE}; \
      echo '# Lines starting with a # are comments, and disregarded.' >> ${TODO_FILE}; \
      echo '# Lines starting with - [ ] are pending todos.' >> ${TODO_FILE}; \
      echo '# Lines starting with - [s] are started todos.' >> ${TODO_FILE}; \
      echo '# Lines starting with - [x] are done todos.' >> ${TODO_FILE}; \
      echo '# Lines starting with - [c] are cancelled todos.' >> ${TODO_FILE}; \
      echo '# Lines have the following format:' >> ${TODO_FILE}; \
      echo '# -<space>[<status>]<space><creation date><space>|<space><todo><space>|<space><modification date>' >> ${TODO_FILE}; \
      echo \"# <creation date> and <modification date> are stored in ISO-8601 compliant strftime format: '${DATETIME_FORMAT_RAW}'\" >> ${TODO_FILE}; \
      echo \"# <creation date> and <modification date> are displayed in strftime format: '${DATETIME_FORMAT_DISPLAY}'\" >> ${TODO_FILE}; \
      echo \"# Type 'git todo help' for details on the available commands.\" >> ${TODO_FILE}; \
    }; \
    help() { \
      git imp-warn-alias \"- list all pending todos\"; \
      git imp-warn-alias \"new <todo> - add a new todo\"; \
      git imp-warn-alias \"done - list all done todos\"; \
      git imp-warn-alias \"cancelled - list all cancelled todos\"; \
      git imp-warn-alias \"all - list all todos\"; \
      git imp-warn-alias \"find <pattern> - find todos matching the pattern\"; \
      git imp-warn-alias \"<number> - show todo with number <number>\"; \
      git imp-warn-alias \"<number> start - mark todo <number> as started\"; \
      git imp-warn-alias \"<number> done - mark todo <number> as done\"; \
      git imp-warn-alias \"<number> cancel - mark todo <number> as cancelled\"; \
      git imp-warn-alias \"<number> delete - delete todo <number>\"; \
    }; \
    numbered_todo_file() { \
      nl -w 4 -s ${LINE_NUMBER_SEPARATOR} -n rz ${TODO_FILE}; \
    }; \
    format_and_sort_numbered_todo_file_lines() { \
      format_numbered_todo_file_lines | sort --ignore-nonprinting -s; \
    }; \
    format_numbered_todo_file_lines() { \
      while read NUMBERED_LINE; do \
        format_numbered_todo_file_line \"${NUMBERED_LINE}\";\
      done; \
    }; \
    is_line_formated_as_expected() { \
      if [ -z \"${LINE}\" ] || echo \"${LINE}\" | grep -q -- '^[[:space:]]*#.*\\|^- \\[[ sxc]\\] [[:digit:]]\\{4\\}-[[:digit:]]\\{2\\}-[[:digit:]]\\{2\\}T[[:digit:]]\\{2\\}:[[:digit:]]\\{2\\}:[[:digit:]]\\{2\\}[-+][[:digit:]]\\{4\\} | .* |\\( [[:digit:]]\\{4\\}-[[:digit:]]\\{2\\}-[[:digit:]]\\{2\\}T[[:digit:]]\\{2\\}:[[:digit:]]\\{2\\}:[[:digit:]]\\{2\\}[-+][[:digit:]]\\{4\\}\\)\\?$'; then \
        return 0; \
       else \
        git imp-error-alias \"unable to parse line ${LINE_NUMBER_ZERO_PADDED}: ${LINE}\"; \
        return 1; \
       fi; \
    }; \
    format_numbered_todo_file_line() { \
      LINE_NUMBER_ZERO_PADDED=${1%%${LINE_NUMBER_SEPARATOR}*}; \
      LINE_NUMBER=$(echo \"${LINE_NUMBER_ZERO_PADDED}\" | sed 's:^00*: :'); \
      LINE=${1#*${LINE_NUMBER_SEPARATOR}}; \
      is_line_formated_as_expected || return 1; \
      case \"${LINE}\" in \
        '#'*|'') \
          echo \"$(tput setaf 8)${LINE}$(tput sgr0)\"; \
          return; \
          ;; \
        '- [ ] '*) \
          LINE=${LINE#'- [ ] '}; \
          SUFFIX_COLOR=''; \
          SUFFIX=''; \
          ;; \
        '- [s] '*) \
          LINE=${LINE#'- [s] '}; \
          SUFFIX_COLOR=\"$(tput bold)$(tput setaf 3)\"; \
          SUFFIX='started'; \
          ;; \
        '- [x] '*) \
          LINE=${LINE#'- [x] '}; \
          SUFFIX_COLOR=\"$(tput bold)$(tput setaf 2)\"; \
          SUFFIX='done'; \
          ;; \
        '- [c] '*) \
          LINE=${LINE#'- [c] '}; \
          SUFFIX_COLOR=\"$(tput bold)$(tput setaf 1)\"; \
          SUFFIX='cancelled'; \
          ;; \
      esac; \
      CREATED_AT=${LINE%% | *}; \
      FORMATTED_CREATED_AT=$(date -jf \"${DATETIME_FORMAT_RAW}\" \"${CREATED_AT}\" +\"${DATETIME_FORMAT_DISPLAY}\"); \
      MODIFIED_AT=${LINE##* |}; \
      if [ -n \"${MODIFIED_AT}\" ]; then \
        FORMATTED_MODIFIED_AT=$(date -jf \"${DATETIME_FORMAT_RAW}\" \"${MODIFIED_AT## }\" +\"${DATETIME_FORMAT_DISPLAY}\"); \
        if [ -z \"${SUFFIX}\" ]; then \
          SUFFIX_COLOR=\"$(tput setaf 8)\"; \
          SUFFIX='reset'; \
        fi; \
      fi; \
      TODO=${LINE#*| }; \
      TODO=${TODO% |*}; \
      printf \"$(tput setaf 3)${LINE_NUMBER} $(tput setaf 2)${FORMATTED_CREATED_AT}$(tput setaf 15) | ${TODO}\"; \
      if [ -n \"${SUFFIX}\" ]; then \
        echo \"${SUFFIX_COLOR} (${SUFFIX}${FORMATTED_MODIFIED_AT:+ on }${FORMATTED_MODIFIED_AT})$(tput sgr0)\"; \
      else \
        echo \"$(tput sgr0)\"; \
      fi; \
    }; \
    todo_file_lines_matching() { \
      numbered_todo_file \
              | grep --color=never \"${1:?missing pattern}\" \
              | grep --color=never -v \"^[[:digit:]]\\{4\\}${LINE_NUMBER_SEPARATOR}#\"; \
    }; \
    formatted_todo_file_lines_matching() { \
      todo_file_lines_matching \"${1}\" | format_and_sort_numbered_todo_file_lines; \
    }; \
    formatted_todo_file_lines_starting_with() { \
      formatted_todo_file_lines_matching \"^[[:digit:]]\\{4\\}${LINE_NUMBER_SEPARATOR}${1:?missing pattern}\"; \
    }; \
    formatted_todo_file_line_with_number() { \
      formatted_todo_file_lines_matching \"^$(padded_line_number ${1})${LINE_NUMBER_SEPARATOR}\"; \
    }; \
    formatted_todo_file_last_line() { \
      numbered_todo_file \
        | tail -1 \
        | format_and_sort_numbered_todo_file_lines; \
    }; \
    padded_line_number() { printf '%04d' ${1:?missing line number}; }; \
    list_all_pending()   { formatted_todo_file_lines_starting_with '- \\[ \\] '; }; \
    list_all_started()   { formatted_todo_file_lines_starting_with '- \\[s\\] '; }; \
    list_all_done()      { formatted_todo_file_lines_starting_with '- \\[x\\] '; }; \
    list_all_cancelled() { formatted_todo_file_lines_starting_with '- \\[c\\] '; }; \
    list_all()           { formatted_todo_file_lines_starting_with '- \\[\\( \\|x\\|c\\)\\] '; }; \
    add() { echo \"- [ ] $(date +\"${DATETIME_FORMAT_RAW}\") | ${*} |\" >> ${TODO_FILE}; }; \
    mark_todo_with() { \
      sed -i.bak \
          -e \"${TARGET_LINE_NUMBER}s/^- \\[.\\]/- [${1}]/\" \
          -e \"${TARGET_LINE_NUMBER}s/\\(.*|.*\\) |.*$/\\1 | $(date +\"${DATETIME_FORMAT_RAW}\")/\" \
          ${TODO_FILE}; \
      formatted_todo_file_line_with_number ${TARGET_LINE_NUMBER}; \
    }; \
    handle_command_for_line_number() { \
      TARGET_LINE_NUMBER=${1}; \
      shift; \
      TARGET_LINE=$(formatted_todo_file_line_with_number ${TARGET_LINE_NUMBER}); \
      [ -n \"${TARGET_LINE}\" ] || return 1; \
      case \"${1}\" in \
        '') \
          echo \"${TARGET_LINE}\"; \
          ;; \
        start|s) \
          mark_todo_with 's'; \
          ;; \
        done|x) \
          mark_todo_with 'x'; \
          ;; \
        cancel|c) \
          mark_todo_with 'c'; \
          ;; \
        reset|r) \
          mark_todo_with ' '; \
          ;; \
        delete) \
          echo \"${TARGET_LINE}\"; \
          git imp-warn-alias \"- to permanently delete this TODO type 'git todo ${TARGET_LINE_NUMBER} DELETE'\"; \
          ;; \
        DELETE) \
          echo \"${TARGET_LINE}\"; \
          sed -i.bak -e \"${TARGET_LINE_NUMBER}d\" ${TODO_FILE}; \
          git imp-warn-alias \"- permanently deleted todo ${TARGET_LINE_NUMBER}\"; \
          ;; \
        *) \
          git imp-error-alias \"- you can only say 'start|s' 'done|x', 'cancel|c', 'reset|r', and 'delete'\"; \
          ;; \
      esac; \
    }; \
    todo() { \
      export CURRENT_ALIAS_NAME=todo; \
      git imp-check-repo || return 1; \
      TODO_FILE=todo.txt; \
      DATETIME_FORMAT_RAW='%Y-%m-%dT%H:%M:%S%z'; \
      DATETIME_FORMAT_DISPLAY='%a %F %R'; \
      LINE_NUMBER_SEPARATOR='::'; \
      init; \
      case \"${1}\" in \
        all) \
          list_all; \
          ;; \
        dump) \
          numbered_todo_file | format_numbered_todo_file_lines; \
          ;; \
        started|s) \
          list_all_started; \
          ;; \
        done|x) \
          list_all_done; \
          ;; \
        cancelled|c) \
          list_all_cancelled; \
          ;; \
        [[:digit:]]|[[:digit:]][[:digit:]]|[[:digit:]][[:digit:]][[:digit:]]) \
          handle_command_for_line_number \"${@}\"; \
          ;; \
        '') \
          list_all_started; \
          list_all_pending; \
          ;; \
        new) \
          shift; \
          add \"${*}\"; \
          formatted_todo_file_last_line; \
          ;; \
        find) \
          shift; \
          formatted_todo_file_lines_matching \"${*}\"; \
          ;; \
        help) \
          help; \
          ;; \
        *) \
          git imp-error-alias invalid command; \
          help; \
          ;; \
      esac; \
    }; \
    todo"

  ## GitHub related

  token = !"f() { if TKN_FROM=\"$(git imp-get-token --location)\"; then echo \"Valid GitHub token found in ${TKN_FROM}.\"; echo \"To manage or rewoke your application tokens go to: https://github.com/settings/applications\"; exit 0; else [ -n \"${TKN_FROM}\" ] && git imp-warn \"I found a token in ${TKN_FROM} but I cannot validate it right now.\"; exit 1; fi; }; f"

  issue = !"f() { git imp-check-repo || exit 1; TKN=\"$(git imp-get-token)\" || exit 1; TITLE=\"${1}\"; OWN_AND_REPO=\"$(git imp-get-own-and-repo)\" || exit 1; [ -z \"${TITLE}\" ] && read -e -p \"Title: \" TITLE; if [ -z \"${TITLE%% }\" ]; then git imp-error \"Title cannot be blank.\"; exit 1; fi; read -e -p \"Body: \" BODY; GH_RESP=\"$(curl -sSi -d \"{\\\"title\\\":\\\"${TITLE}\\\",\\\"body\\\":\\\"${BODY}\\\"}\" https://api.github.com/repos/${OWN_AND_REPO}/issues?access_token=${TKN})\"; [ \"$(echo \"${GH_RESP}\" | head -1 | grep \"HTTP/1.1 2\")\" != \"\" ] && OK=true || OK=false; ! $OK && echo \"Error creating a GitHub issue.\" && echo ${GH_RESP} && exit 1; URL=\"$(echo \"${GH_RESP}\" | grep \"html_url\" | head -1 | sed -e \"s/.*\\\"html_url\\\": \\\"\\(.*\\)\\\".*/\\1/\")\"; echo \"New issue #${URL##*/} successfully created at $URL\"; }; f"

  issues = !"from_cache() { if [ -f $GHI_LOG ]; then git imp-warn \"This is the last issue list I remember from $(stat -qf '%Sm' ${GHI_LOG}):\"; cat ${GHI_LOG}; else git imp-error \"I don't remember any issue list here.\"; exit 1; fi; exit 0;}; f() { git imp-check-repo || exit 1; GHI_LOG='.git-issues.cache'; INCLUDE_LABELS=$(git config --get --bool github.issues.show-labels || echo false); INCLUDE_REPO=$(git config --get --bool github.issues.show-repo || echo false); export DO_COLOR=$(git config --get --bool github.issues.color || echo true); while [ \"${1:0:1}\" == \"-\" ]; do case ${1:1} in r|-repo) INCLUDE_REPO=true;; -no-repo) INCLUDE_REPO=false;; n|-no-color) DO_COLOR=false;; -color) DO_COLOR=true;; c|-cached) from_cache;; l|-labels) INCLUDE_LABELS=true;; -no-labels) INCLUDE_LABELS=false;; *) git imp-error \"Unkown flag: ${1}\"; exit 1;; esac; shift; done; for p in ${@}; do [ \"${p:0:1}\" == \"-\" ] && { git imp-error \"Found flag $p when expecting assignee.\"; git imp-error \"Flags must come before assignee.\n\"; exit 1;}; done; ASSIGNEE=${1:-$(git config --get github.issues.assignee || git config --get user.name)}; TKN=\"$(git imp-get-token)\" || from_cache; OWN_AND_REPO=\"$(git imp-get-own-and-repo)\" || exit 1; GH_RESP=\"$(curl -sSL https://api.github.com/repos/${OWN_AND_REPO}/issues?$( [ \"${ASSIGNEE}\" != \"all\" ] && echo \"assignee=$( [ -n \"${ASSIGNEE}\" ] && echo \"${ASSIGNEE//assigned/*}\")\")'&'access_token=${TKN})\"; if [ $? -ne 0 ]; then git imp-error \"The connection to GitHub failed. Please verify the internet availability.\"; from_cache; fi; GH_RESP=$(git imp-sanitize-json-resp \"${GH_RESP}\"); python -c \"import json,datetime as dt, dateutil as du, dateutil.parser as dup, dateutil.relativedelta as dur; d = lambda x: dur.relativedelta(dt.datetime.now(du.tz.tzlocal()),dup.parse(x)); color = lambda rgb: (int(36 * (int(rgb[:2], 16) * 5 / 256) + 6 * (int(rgb[2:4], 16) * 5 / 256) + (int(rgb[4:], 16) * 5 / 256) + 16)); label_str = lambda label_dict: $( $DO_COLOR && echo \"' \\033[48;5;%sm$(tput setaf 0)$(tput bold) %s $(tput sgr0)' % (str(color(label_dict['color'])), label_dict['name'])\" || echo \"' ' + label_dict['name']\" ); issues=json.loads('${GH_RESP}'.decode('utf-8'))['body']; print('\\n'.join(['$(git imp-printf 233 $(${INCLUDE_REPO} && echo ${OWN_AND_REPO}))$(git imp-printf 3 '#%-3d') $(git imp-printf 2 '%-12s') | %s%s$(git imp-printf 1 '%s')$(git imp-printf 4 '%s')' % (i['number'], reduce((lambda acc, x: str(getattr(d(i['created_at']),x)) + ' ' + (x if getattr(d(i['created_at']),x) is not 1 else x[:-1]) + ' ago' if acc[:1] is '0' else acc),['0', 'years','months','days','hours','minutes']), i['title'], ''$($INCLUDE_LABELS && echo \".join([ label_str(label) for label in i['labels'] ])\"), ' (' + i['milestone']['title'] + ')' if i['milestone'] else '', ' [' + i['assignee']['login'] + ']' if i['assignee'] else '') for i in issues]).encode('utf-8') if issues else '$(git imp-warn No issues found. 2>&1)')\" | tee ${GHI_LOG}; }; f"

  release = !"intomsg() { echo ${@} >> ${TAG_MSG_FILE}; }; echointomsg() { echo ${@}; intomsg ${@}; }; curl_issue() { ISSUE_OWN_AND_REPO=${i%%#*}; GH_RESP=\"$(curl -sS https://api.github.com/repos/${ISSUE_OWN_AND_REPO:-${OWN_AND_REPO}}/issues/${1#*\\#}?access_token=${TKN} | egrep \"^  \\\"title\\\":.*,$\" | sed \"s/.*\\\": *\\\"\\(.*\\)\\\",/\\1/\")\"; echo \"  - ${1}: ${GH_RESP}\" ; }; f() { TAG_MSG_FILE=\".git-tag-msg-template.tmp\"; git imp-check-repo || exit 1; FROM_COMMIT=\"$(git describe --abbrev=0 2> /dev/null)\"; if [ -z \"${FROM_COMMIT}\" ]; then FROM_COMMIT=\"$(git log --format=\"%h\" | tail -1)\"; FROM_COMMIT_TYPE=\"initial commit\"; TAG_FOUND=false; else TAG_FOUND=true; FROM_COMMIT_TYPE=\"last annotated tag\"; fi; TO_COMMIT=\"HEAD\"; if [ \"$(git describe --always ${FROM_COMMIT})\" == \"$(git describe --always ${TO_COMMIT})\" ] && $TAG_FOUND; then git imp-warn \"${TO_COMMIT} has already been tagged as ${FROM_COMMIT}. Nothing to do.\"; exit 1; fi; SUGGESTED_NEW_TAG=\"v0.1\"; LAST_TAG_SUFFIX=\"${FROM_COMMIT##*.}\"; $TAG_FOUND && if [[ \"${FROM_COMMIT}\" =~ ^v20[0-9][0-9].(01|02|03|04|05|06|07|08|09|10|11|12).[0-3][0-9]$ ]]; then SUGGESTED_NEW_TAG=\"$(date +\"v%Y.%m.%d\")\"; else [ -n \"${LAST_TAG_SUFFIX##*[!0-9]*}\" ] && SUGGESTED_NEW_TAG=\"${FROM_COMMIT%.*}.$(($LAST_TAG_SUFFIX+1))\"; fi; $TAG_FOUND && git imp-warn \"Current tag: ${FROM_COMMIT}\" || git imp-warn \"This will be the first tag.\"; read -p \"New tag name [leave blank for '${SUGGESTED_NEW_TAG}']: v\" NEW_TAG_NAME; [ -n \"${NEW_TAG_NAME}\" ] && NEW_TAG_NAME=\"v${NEW_TAG_NAME}\" || NEW_TAG_NAME=\"${SUGGESTED_NEW_TAG}\"; if [ -n \"$(git show \"${NEW_TAG_NAME}\" 2> /dev/null)\" ]; then git imp-error \"Tag '${NEW_TAG_NAME}' already exists.\"; exit 1; fi; OWN_AND_REPO=\"$(git imp-get-own-and-repo)\" || GH_REPO_FOUND=false; COMMIT_COUNT=$(git log --color=never --format=\"%s\" ${FROM_COMMIT}..${TO_COMMIT} | wc -l | tr -d ' ' ) ; COMMITS=($(git log --color=never --reverse --format='%h' ${FROM_COMMIT}..${TO_COMMIT})); ISSUES=($(git log --color=never --format=\"%s\" ${FROM_COMMIT}..${TO_COMMIT} | egrep -o '([-_a-zA-Z0-9]+/[-_a-zA-Z0-9]+)?#[0-9]+' | sort -u)); [ ${COMMIT_COUNT} -eq 0 ] && exit; printf \"Release ${NEW_TAG_NAME}\\n\\n\" > ${TAG_MSG_FILE}; echointomsg \"${#ISSUES[@]} GitHub issues were mentioned in the ${COMMIT_COUNT} commit messages since the ${FROM_COMMIT_TYPE} ${FROM_COMMIT}$(if [ \"${#ISSUES[@]}\" == \"0\" ]; then echo '.'; else echo ':'; fi)\"; intomsg; if $GH_REPO_FOUND; then TKN=\"$(git imp-get-token)\" || exit; for i in ${ISSUES[@]}; do echointomsg $(curl_issue ${i}); done; intomsg; fi; intomsg \"# Commits since the ${FROM_COMMIT_TYPE} ${FROM_COMMIT}:\"; for c in ${COMMITS[@]}; do intomsg $(git log --color=never --format='# - (%h) %s [%an]' -1 $c); done; intomsg; intomsg \"Diff with the previous tag: https://github.com/${OWN_AND_REPO}/compare/${FROM_COMMIT}...${NEW_TAG_NAME}\"; intomsg; intomsg \"# You might want to modify the tag message here. Lines starting\"; intomsg \"# with '#' will be ignored, but an empty message *DOES NOT* abort the tag.\"; GT_MESSAGE_EDITOR=\"$(git config --get core.editor || which vim || which vi)\"; ${GT_MESSAGE_EDITOR} ${TAG_MSG_FILE}; git tag -a --file=${TAG_MSG_FILE} ${NEW_TAG_NAME} || exit 1; if $GH_REPO_FOUND; then git imp-warn \"After pushing the new tag (with 'git push --tags'), you might:\"; git imp-warn \"- visit following permalink to see it on GitHub: https://github.com/${OWN_AND_REPO}/releases/tag/${NEW_TAG_NAME}\"; git imp-warn \"- visit following permalink to compare it with the previous tag: https://github.com/${OWN_AND_REPO}/compare/${FROM_COMMIT}...${NEW_TAG_NAME}\"; fi; git imp-warn \"To delete the newly created tag, execute: 'git tag -d ${NEW_TAG_NAME}'\"; }; f"

  # SOURCE: https://stackoverflow.com/a/23486788
  squash-all = "!f(){ git imp-warn \"This will squash ALL $(git rev-list --count HEAD) commits into one. The commit history of the current repo will be LOST. Press CTRL-C to abort.\"; DEFAULT_COMMIT_MSG='initial commit'; read -p \"Commit message: [default: '${DEFAULT_COMMIT_MSG}'] \" COMMIT_MSG; git reset $(git commit-tree HEAD^{tree} -m \"${COMMIT_MSG:-$DEFAULT_COMMIT_MSG}\") && git h && git imp-success 'Done!'; };f"
  init-from-template = "!f(){ if git imp-check-repo 2>/dev/null; then git imp-error 'This is already a git repo.'; exit 1; fi; if [ -n \"${1}\" ]; then TEMPLATE_REPO_URL=\"${1}\"; shift; else git imp-error 'Provide the URL of the template repo.'; exit 1; fi; git init && git fetch --depth=1 -n \"${TEMPLATE_REPO_URL}\" && git reset --hard $(git commit-tree FETCH_HEAD^{tree} -m \"initial commit\") && git imp-success \"Repo initialized from template ${TEMPLATE_REPO_URL}!\"; };f"

  update-gitconfig = !"f() { if [ -L ~/.gitconfig ]; then git imp-error '~/.gitconfig is a simbolic link. Update the original file instead. The command update-gitconfig works for standalone files installed via curl'; exit 1; fi; GH_LOCAL_FILE=~/.gitconfig.local && touch \"${GH_LOCAL_FILE}\" && GH_PREV_USER_NAME=\"$(git config user.name || echo '')\" && GH_PREV_USER_EMAIL=\"$(git config user.email || echo '')\" && GH_PREV_TOKEN=\"$(git config github.token || echo '')\" && GH_CONFIG_BACKUP_FILENAME=~/.gitconfig_backups/.gitconfig_$(date +\"%Y%m%d%H%M%S\").bak && echo \"Saving a backup of the current ~/.gitconfig file as ${GH_CONFIG_BACKUP_FILENAME}...\" && mkdir -p ~/.gitconfig_backups && cp -v ~/.gitconfig \"${GH_CONFIG_BACKUP_FILENAME}\" && echo && echo \"Downloading .gitconfig from rbf.li/gitconfig ...\" && curl --progress-bar -L rbf.li/gitconfig -o ~/.gitconfig && echo && if [ -n \"${GH_PREV_USER_NAME}\" ] && [ -n \"${GH_PREV_USER_EMAIL}\" ]; then echo \"Ensuring that the user name (${GH_PREV_USER_NAME}) and email (${GH_PREV_USER_EMAIL}) are setup in ${GH_LOCAL_FILE} file...\"; git config --file ${GH_LOCAL_FILE} user.name \"${GH_PREV_USER_NAME}\" && git config --file ${GH_LOCAL_FILE} user.email \"${GH_PREV_USER_EMAIL}\"; else echo \"Please add your username and email to the ${GH_LOCAL_FILE} file to properly author your commits! Run:\" && echo \"git config --file ${GH_LOCAL_FILE} user.name YOUR_USER_NAME && git config --file ${GH_LOCAL_FILE} user.email YOUR_USER_EMAIL\"; fi && if [ -n \"${GH_PREV_TOKEN}\" ]; then echo \"Ensuring that the existent GitHub token is setup in ${GH_LOCAL_FILE} file...\" && git config --file ${GH_LOCAL_FILE} github.token \"${GH_PREV_TOKEN}\"; fi && if which diff 1>/dev/null 2>/dev/null; then echo && echo \"Lines changed from previous version:\" && echo && diff --side-by-side --suppress-common-lines --minimal --report-identical-files \"${GH_CONFIG_BACKUP_FILENAME}\" ~/.gitconfig; fi; }; f" #'

  # Following imp-* aliases are meant to be internally used

  # SOURCE: 16sep2021 https://stackoverflow.com/a/67625120
  imp-main-branch-name = !git -c color.ui=never branch | cut -c 3- | grep --color=never -E '^master$|^main$'

  imp-current-branch-name = rev-parse --abbrev-ref HEAD

  imp-is-main-branch-checked-out = ![ "$(git imp-current-branch-name)" = "$(git imp-main-branch-name)" ]

  imp-check-if-branch-exists           = !"f() { git rev-parse --abbrev-ref \"${@?Missing branch name}\" 1>/dev/null 2>&1; }; f"
  imp-check-if-branch-exists-in-origin = !"f() { git rev-parse --abbrev-ref origin/\"${@?Missing branch name}\" 1>/dev/null 2>&1; }; f"

  # SOURCE: 16oct2021 https://stackoverflow.com/a/9753364
  imp-upstream-branch-name = !"git for-each-ref --format='%(upstream:short)' \"$(git symbolic-ref -q \"${1:-HEAD}\")\""

  imp-upstream-main-branch-name = !"git imp-upstream-branch-name \"refs/heads/$(git imp-main-branch-name)\""

  imp-is-current-branch-up-to-date-with-upstream-main = !"[ -n \"$(git branch --contains \"$(git imp-upstream-main-branch-name)\" --list \"$(git imp-current-branch-name)\")\" ]"

  imp-repo-clone = !"f() { \
    export CURRENT_ALIAS_NAME='repo clone'; \
    REPO_URL=\"${1}\"; \
    shift; \
    case \"${REPO_URL}\" in \
      git@github.com:*.git) \
        REPO_DIR=\"${REPO_URL#git@github.com:}\"; \
        REPO_DIR=\"${REPO_DIR%.git}\"; \
        REPO_DIR=\"${REPO_DIR_BASE}/github/${REPO_DIR}\"; \
        ;; \
      git@gitlab.com:*.git) \
        REPO_DIR=\"${REPO_URL#git@gitlab.com:}\"; \
        REPO_DIR=\"${REPO_DIR%.git}\"; \
        REPO_DIR=\"${REPO_DIR_BASE}/gitlab/${REPO_DIR}\"; \
        ;; \
      git@bitbucket.org:*.git) \
        REPO_DIR=\"${REPO_URL#git@bitbucket.org:}\"; \
        REPO_DIR=\"${REPO_DIR%.git}\"; \
        REPO_DIR=\"${REPO_DIR_BASE}/bitbucket/${REPO_DIR}\"; \
        ;; \
      *) \
        git imp-error-alias \"accepts only repo SSH URLs in the following form: 'git@{github.com,gitlab.com,bitbucket.org}:*.git'\"; \
        return 1; \
        ;; \
    esac; \
    if [ -d \"${REPO_DIR}\" ]; then \
      cd \"${REPO_DIR}\"; \
      if [ -z \"$(command ls -A)\" ]; then \
        git imp-warn-alias \"- the folder '${REPO_DIR}' already exists but is empty\"; \
      elif ! git remote 1>/dev/null 2>&1; then \
        git imp-error-alias \"- the folder '${REPO_DIR}' already exists and is not empty\"; \
        return 1; \
      elif [ \"${REPO_URL}\" = \"$(git remote get-url --push origin)\" ]; then \
        git imp-warn-alias \"- '${REPO_URL}' is already checked out at '${REPO_DIR}'\"; \
        IS_CLONING_PENDING=false; \
      else \
        git imp-error-alias \"- the folder '${REPO_DIR}' already exists but repo '$(git remote get-url --push origin)' is checked out instead of '${REPO_URL}'\"; \
        return 1; \
      fi; \
    else \
      if mkdir -p \"${REPO_DIR}\"; then \
        git imp-success-alias \" - successfully created directory '${REPO_DIR}'\"; \
        cd \"${REPO_DIR}\"; \
      else \
        git imp-error-alias \" - unable to create directory '${REPO_DIR}'\"; \
        return 1; \
      fi; \
    fi; \
    if ${IS_CLONING_PENDING:-true}; then \
      if git clone --progress -- \"${REPO_URL}\" \"${REPO_DIR}\"; then \
        git imp-success-alias \"${REPO_URL} - successfully cloned at '${REPO_DIR}'\"; \
      else \
        git imp-error-alias \"${REPO_URL} - unable to clone at '${REPO_DIR}'\"; \
        return 1; \
      fi; \
    fi; \
    git imp-repo-open \"${REPO_DIR}\"; \
  }; f"

  imp-repo-list-print = !"\
    igh() { echo \"  \"; };\
    igl() { echo \"$(tput setaf 202)  $(tput setaf 15)\"; };\
    ibb() { echo \"$(tput setaf 27)  $(tput setaf 15)\"; };\
    currentrepo() { [ \"$(pwd)\" = \"${1}\" ] && echo '*' || echo 'x' ; }; \
    prettifypwd() { \
      pwd | \
        sed -e \"s:${REPO_DIR_BASE}/::\" \
            -e \"s:^github/: $(igh)%C(dim)%<|(${1:-30})GitHub/:\" \
            -e \"s:^gitlab/: $(igl)%C(dim)%<|(${1:-30})GitLab/:\" \
            -e \"s:^bitbucket/: $(ibb)%C(dim)%<|(${1:-30})Bitbucket/:\" \
            -e \"s:^\\([[:alnum:]]*\\)/: x  %C(dim)%<|(${1:-30})\\1/:\" \
            -e \"s:/: %C(no-dim)%C(white bold):\"; \
    }; \
    f() { \
      git -c color.ui=always log \
        --max-count=1 \
        --date=human \
        --pretty=tformat:\"$(currentrepo \"${3}\")$(prettifypwd \"${2}\") %>|(${1:-30})%C(no-bold)%C(dim)* %C(yellow)%h%C(green) %>(16)%ad %C(white)| %<(70)%s %C(blue)[%an] %G?%C(normal)%C(red bold)%<|($(tput cols),trunc)%d%C(reset)\"; \
    }; f"

  imp-repo-list = !"f() { \
    export CURRENT_ALIAS_NAME='repo list'; \
    case \"${1}\" in \
      --porcelain|-p) \
        shift; \
        find \"${REPO_DIR_BASE}\" -maxdepth 6 \
                                  -path \"${REPO_DIR_BASE}*${*}*\" \
                                  -not -path '*/.git/*' \
                                  -type d \
                                  -name .git \
                                  -execdir pwd \\; \
                                  ; \
        return 0; \
        ;; \
      -*) \
        git imp-error-alias \"- unrecognized option ${1}\"; \
        ;; \
    esac; \
    MAX_DOMAIN_LENGTH=$(($(f --porcelain \"${*}\" \
                          | sed -e \"s:${REPO_DIR_BASE}/::\" \
                          | sed -e 's:/.*::' \
                          | awk '{print length}' \
                          | sort -nr \
                          | head -1 ) + 6)); \
    MAX_REPO_LENGTH=$(($(f --porcelain \"${*}\" \
                          | awk '{print length}' \
                          | sort -nr \
                          | head -1 ) - 6 + MAX_DOMAIN_LENGTH - ${#REPO_DIR_BASE})); \
    find \"${REPO_DIR_BASE}\" -maxdepth 6 \
                              -path \"${REPO_DIR_BASE}*${*}*\" \
                              -not -path '*/.git/*' \
                              -type d \
                              -name .git \
                              -execdir git imp-repo-list-print ${MAX_REPO_LENGTH} ${MAX_DOMAIN_LENGTH} $(pwd) \\; \
      | sort --key=4 --key=3 --ignore-leading-blanks \
      | sed 's/^x/ /'; \
  }; f"

  imp-repo-open = !"f() { \
    export CURRENT_ALIAS_NAME='repo open'; \
    IS_SUBLP_TO_BE_CALLED=false; \
    IS_TO_BE_OPENED_IN_TMUX=${IS_RUNNING_INSIDE_TMUX:-false}; \
    for OPTION in "$@"; do \
      case ${OPTION} in \
        --open-sublime-text|-s) \
          IS_SUBLP_TO_BE_CALLED=true; \
          shift; \
          ;; \
        --open-in-tmux|-t) \
          IS_TO_BE_OPENED_IN_TMUX=true; \
          shift; \
          ;; \
        --open-in-subshell|-z) \
          IS_TO_BE_OPENED_IN_TMUX=false; \
          shift; \
          ;; \
        --) \
          shift; \
          break; \
          ;; \
        -*) \
          git imp-error-alias - invalid option ${OPTION}; \
          git imp-warn-alias - only accepted: '-s|--open-sublime-text, --open-in-tmux|-t, --open-in-subshell|-z'; \
          return 1; \
          ;; \
        *) \
          break; \
          ;; \
      esac; \
    done; \
    REPO_PATTERN=\"${*#${REPO_DIR_BASE}/}\"; \
    export CURRENT_ALIAS_ARGUMENTS=''; \
    if $IS_TO_BE_OPENED_IN_TMUX; then \
      CURRENT_ALIAS_ARGUMENTS+=' --open-in-tmux'; \
    else \
      CURRENT_ALIAS_ARGUMENTS+=' --open-in-subshell'; \
    fi; \
    if $IS_SUBLP_TO_BE_CALLED; then \
      CURRENT_ALIAS_ARGUMENTS+=' --open-sublime-text'; \
    fi; \
    if [ -z \"${REPO_PATTERN}\" ]; then \
      git imp-error-alias - missing pattern; \
      return 1; \
    fi; \
    MATCHED_REPOS=($(git imp-repo-list --porcelain \"${REPO_PATTERN}\")); \
    case ${#MATCHED_REPOS[@]} in \
      0) \
        CURRENT_ALIAS_ARGUMENTS+=\" -- ${REPO_PATTERN}\"; \
        git imp-error-alias no repo found; \
        git imp-repo-list; \
        return 1; \
        ;; \
      1) \
        CURRENT_ALIAS_ARGUMENTS+=\" -- ${MATCHED_REPOS[0]}\"; \
        if $IS_TO_BE_OPENED_IN_TMUX; then \
          if tmux new-window -c \"${MATCHED_REPOS[0]}\" \
                          -n $(basename \"${MATCHED_REPOS[0]}\") \
                          -e IS_SUBLP_TO_BE_CALLED=${IS_SUBLP_TO_BE_CALLED} \
                          -e IS_ALLOWED_TO_PRINT_LOGIN_GREETING=false \
                          -e IS_CONTEXT_TO_BE_PRINTED=true; then \
            git imp-success-alias; \
          else \
            git imp-error-alias; \
          fi; \
        else \
          git imp-success-alias; \
          echo; \
          cd \"${MATCHED_REPOS[0]}\"; \
          IS_SUBLP_TO_BE_CALLED=${IS_SUBLP_TO_BE_CALLED} IS_CONTEXT_TO_BE_PRINTED=true RUNNING_INSIDE_SUB_SHELL=true $SHELL; \
        fi; \
        ;; \
      *) \
        CURRENT_ALIAS_ARGUMENTS+=\" -- ${REPO_PATTERN}\"; \
        git imp-error-alias \"ambiguous pattern: ${#MATCHED_REPOS[@]} repos found matching '${REPO_PATTERN}'\"; \
        git imp-repo-list \"${REPO_PATTERN}\"; \
        return 1; \
        ;; \
    esac; \
  }; f"

  # SOURCE: 22oct2021 https://stackoverflow.com/a/1549155
  imp-check-latest-pushed-commit-for-current-branch = !"f() {\
    CURRENT_BRANCH_NAME=$(git imp-current-branch-name); \
    UPSTREAM_BRANCH_NAME=$(git imp-upstream-branch-name); \
    if [ -z \"${UPSTREAM_BRANCH_NAME}\" ]; then \
      exit; \
    elif [ \"$(git rev-parse --short \"${CURRENT_BRANCH_NAME}\")\" = \"$(git rev-parse --short \"${UPSTREAM_BRANCH_NAME}\")\" ]; then \
      exit; \
    fi; \
    MOST_RECENT_COMMON_ANCESTOR=$(git merge-base \"${CURRENT_BRANCH_NAME}\" \"${UPSTREAM_BRANCH_NAME}\"); \
    if (( $(git rev-list --count HEAD..$(git imp-upstream-branch-name)) > 0 )); then \
      THRESHOLD_IN_HOURS=1; \
      ((($(date +'%s') - $(git log --pretty=format:'%at' -1 ${MOST_RECENT_COMMON_ANCESTOR})) < (60 * 60 * THRESHOLD_IN_HOURS))) && exit; \
      echo; \
      echo \"You haven't pulled in a while.\"; \
      FORMAT_BRANCHES=\"%C(red bold)${UPSTREAM_BRANCH_NAME}%C(white no-bold) in %C(green bold)${CURRENT_BRANCH_NAME}%C(white no-bold)\"; \
      git log --max-count=1 --pretty=format:\"The most recent commit in %C(red bold)${UPSTREAM_BRANCH_NAME}%C(white no-bold) is from %C(bold)%ar%C(reset).%C(white dim) %C(yellow)%h %C(white)on %ad%C(reset)\" ${UPSTREAM_BRANCH_NAME}; \
    elif (( $(git rev-list --count $(git imp-upstream-branch-name)..HEAD) > 0 )); then \
      MOST_RECENT_COMMON_ANCESTOR_CHILD=$(git imp-child-commit-in-current-branch ${MOST_RECENT_COMMON_ANCESTOR}); \
      THRESHOLD_IN_HOURS=1; \
      ((($(date +'%s') - $(git log --pretty=format:'%at' -1 ${MOST_RECENT_COMMON_ANCESTOR_CHILD})) < (60 * 60 * THRESHOLD_IN_HOURS))) && exit; \
      echo; \
      git log --max-count=1 --pretty=format:\"It seems you haven't pushed since at least %C(bold)%ar%C(reset).%n\" ${MOST_RECENT_COMMON_ANCESTOR_CHILD}; \
      FORMAT_BRANCHES=\"%C(green bold)${CURRENT_BRANCH_NAME}%C(white no-bold) in %C(red bold)${UPSTREAM_BRANCH_NAME}%C(white no-bold)\"; \
    fi; \
    git log --max-count=1 --pretty=format:\"The most recent commit from ${FORMAT_BRANCHES} is from %C(bold)%ar%C(reset).%C(white dim) %C(yellow)%h %C(white)on %ad%C(reset)\" ${MOST_RECENT_COMMON_ANCESTOR}; \
  }; f"

  # SOURCE: 25oct2021 https://stackoverflow.com/questions/1761825/referencing-the-child-of-a-commit-in-git/20141722#20141722
  imp-child-commit-in-current-branch = !"f() { git log --pretty=tformat:'%H' HEAD...${1?-missing commit-ish} | tail -1; }; f"

  imp-printf = !"c() { \
    if [ ! -z \"${1##*[!0-9]*}\" ]; then \
      C=$1; \
      shift; \
      if [ ! -z \"${1##*[!0-9]*}\" ]; then \
        B=$1; \
        DO_BACKGROUND=true; \
        shift; \
      else \
        DO_BACKGROUND=false; \
      fi; \
    else \
      DO_COLOR=false; \
    fi; \
    TEXT=\"$($DO_COLOR && tput setaf $C)$($DO_COLOR && $DO_BACKGROUND && tput setab $B && tput bold && echo ' ')${@//\\%/%%}$($DO_COLOR && $DO_BACKGROUND &&  echo ' ')$($DO_COLOR && tput sgr0)\"; \
    if (( ${#TEXT} < ($(tput cols) - 20) )); then \
      printf \"${TEXT}\"; \
    else \
      printf \"${TEXT}\" | fold -w 76 -s; \
    fi; \
  }; c"

  # Like imp-printf but with a newline at the end.
  imp-echo = !"c() { git imp-printf \"$@\n\"; }; c"
  imp-error = !"c() { git imp-printf 1   \"error:   $@\n\" >&2; exit 1; }; c"
  imp-warn = !"c() { git imp-printf 3    \"hint:    $@\n\" >&2; }; c"
  imp-success = !"c() { git imp-printf 2 \"success: $@\n\"; }; c"

  imp-underline = !"c() { echo \"$(tput smul)$@$(tput rmul)\"; }; c"
  imp-current-alias-name = !"c() { git imp-underline git ${CURRENT_ALIAS_NAME:?not set, empty or not exported}; }; c"

  imp-error-alias = !"c() { git imp-error $(git imp-current-alias-name)${CURRENT_ALIAS_ARGUMENTS}${CURRENT_ALIAS_ARGUMENTS+; #} ${@}; }; c"
  imp-warn-alias = !"c() { git imp-warn $(git imp-current-alias-name)${CURRENT_ALIAS_ARGUMENTS}${CURRENT_ALIAS_ARGUMENTS+; #} ${@}; }; c"
  imp-success-alias = !"c() { git imp-success $(git imp-current-alias-name)${CURRENT_ALIAS_ARGUMENTS}${CURRENT_ALIAS_ARGUMENTS+; #} ${@}; }; c"

  imp-are-there-staged-modifications = !"if git status --porcelain | grep '^M[ MD]\\|^A[ MD]\\|^D \\|^R[ MD]\\|^C[ MD]' 1>/dev/null 2>&1; then exit; else git imp-error there are no changes staged to commit; if git imp-is-tree-clean; then git imp-warn there are no changes or untracked files to stage; else git imp-warn \"try 'git add .' or its alias 'git aa' to stage all changes, including untracked files\"; git status --short --branch; fi; exit 1; fi;"
  imp-are-there-unstaged-modifications = !"if git status --porcelain | grep '^.[MD]' 1>/dev/null 2>&1; then exit 0; else exit 1; fi;"
  imp-is-there-nothing-preventing-a-commit = !"if git status --porcelain | grep '^DD\\|^AU\\|^UD\\|^UA\\|^DU\\|^AA\\|^UU' 1>&2; then git imp-error solve the unmerged files before committing; exit 1; fi;"
  imp-is-there-something-untracked = !"if git status --porcelain | grep '^??' 1>&2; then git imp-warn there are untracked files that will not be added to the commit; fi;"
  imp-is-a-commit-possible = !git imp-are-there-staged-modifications && git imp-is-there-nothing-preventing-a-commit && git imp-is-there-something-untracked

  imp-is-cam-reasonable = !"f() { \
      export CURRENT_ALIAS_NAME=cam; \
      if git imp-are-there-staged-modifications 1>/dev/null 2>&1 && git imp-are-there-unstaged-modifications 1>/dev/null 2>&1; then \
        git imp-error-alias does not seem reasonable here - there staged and unstaged changes; \
        git status --short --branch; \
        git imp-warn \"consider using 'git cm' instead\"; \
        return 1; \
      else \
        return 0; \
      fi;\
    }; f"

  imp-check-repo = !"f() { if [ -z \"$(git rev-parse --git-dir 2> /dev/null)\" ]; then git imp-error-alias \"- it doesn't seem to be a git repo here.\"; exit 1; else exit 0; fi; }; f"
  imp-is-tree-clean = !"[ -z \"$(git status --porcelain)\" ]"
  imp-check-clean-tree = !"f() { if ! git imp-is-tree-clean; then git imp-error \"there are uncommitted changes or untracked files - commit or stash them before continuing\"; exit 1; fi; }; f"

  imp-prevent-inception = !"f() { \
    if ${RUNNING_INSIDE_SUB_SHELL:-false}; then \
      git imp-error-alias 'started this sub-shell and does not allow shellception - type CTRL-D to exit this sub-shell'; \
      return 1; \
    fi; \
  }; f"

  # SOURCE: 21oct2021 https://stackoverflow.com/a/1655488
  imp-is-output-too-wide-for-terminal-for-command = !"f() { \
    MAX_DIFF_LINE_LENGTH=$(GIT_PAGER='' git ${*} \
                              | grep '^[+-]' \
                              | awk '{print length}' \
                              | sort -nr \
                              | head -1 \
                            || echo 0); \
    TERMINAL_HALF_WIDTH=$(( $(tput cols) / 2 )); \
    ((MAX_DIFF_LINE_LENGTH > (TERMINAL_HALF_WIDTH - 6))); \
  }; f"

  # First alias written in multiple lines using \ at the end of each line.
  # Note that it has to be treated as written in one line still, i.e. each
  # command must be manually terminated with a semicolon.
  # SOURCE: 14oct2021 https://unix.stackexchange.com/a/631653
  # SOURCE: 14oct2021 https://stackoverflow.com/a/44811468
  imp-sanitize-string-for-branch-name = !"f() { \
    if [ -z \"${*}\" ]; then \
      git imp-error 'Must provide a string to sanitize.'; \
      exit 1; \
    fi; \
    echo \"${*}\" \
     | iconv -t ASCII//TRANSLIT \
     | tr -d '['\"'\"'\\\"`~´¨^]' \
     | tr -sc '[[:alnum:]]' '-' \
     | tr "[:upper:]" "[:lower:]" \
     | sed  -e 's/[^[:alnum:]]*$//' \
            -e 's/^[^[:alnum:]]*//'; \
  }; f"

  # We use this instead of the bash command 'column' because some versions of the command do not deal well with color codes to properly calculate the width.
  # SOURCE: https://superuser.com/questions/648665/bash-column-command-confused-by-ansi-color-escapes
  imp-get-max-branch-name-length = !"f() { max_length=0; for b in $(git branch --list $([ \"${1}\" == 'include-remote-branches' ] && echo '--all') --no-color | tr -d '* ' | grep -v HEAD | sed 's|remotes/||g'); do length=${#b}; if (( max_length < length )); then max_length=${length}; fi; done; echo ${max_length}; }; f"

  imp-check-commit-message-length = !"f() { recommended_length=50; max_length=70; length=${#1}; if (( max_length < length )); then git imp-error \"commit message too long (max ${max_length} chars)\"; git imp-printf 2 \"${1:0:${recommended_length}}\"; git imp-printf 3 \"${1:${recommended_length}:(( max_length - recommended_length ))}\"; git imp-printf 1 \"${1:${max_length}}\\n\"; git imp-warn \"recommended length is < ${recommended_length} chars\"; exit 1; else exit 0; fi; }; f"

  imp-validate-token = !"f() { curl -sfm 5 https://api.github.com/user?access_token=${1} 2>&1 1>/dev/null; }; f"

  imp-get-token = !"f() { GIT_ADMIN_NOTE=\"To manage or rewoke your application tokens go to: https://github.com/settings/applications\"; if TKN=\"$(git config --local github.token 2>/dev/null)\"; then TKN_FROM='local git config'; TKN_RESET_CMD='git config --local --unset github.token'; elif TKN=\"$(git config --global github.token 2>/dev/null)\"; then TKN_FROM='global git config'; TKN_RESET_CMD='git config --global --unset github.token'; else TKN=\"${GITHUB_TOKEN}\"; TKN_FROM='system variable GITHUB_TOKEN'; TKN_RESET_CMD='unset GITHUB_TOKEN'; fi; if [ -n \"${TKN}\" ]; then git imp-validate-token ${TKN}; RES=$?; [ ${RES} -eq 0 ] && { [ \"${1}\" == \"--location\" ] && echo ${TKN_FROM} || echo ${TKN}; } && exit 0; if [ ${RES} -eq 22 ]; then git imp-error \"The GitHub token found in ${TKN_FROM} doesn't seem to be valid.\"; git imp-error \"To create a new one, remove it (i.e. '${TKN_RESET_CMD}') and re-run this command.\"; git imp-error \"${GIT_ADMIN_NOTE}\"; exit 1; fi; git imp-error \"github.com doesn't seem currently reachable. Please verify the internet availability.\"; [ \"${1}\" == \"--location\" ] && echo ${TKN_FROM} || echo ${TKN}; exit 1; fi; git imp-warn \"Requesting new authentification token...\"; NAME=\"$(git config --get user.name)\"; read -e -p \"GitHub username [leave blank to use '${NAME}']: \" USER; read -e -p \"Two-factor authentication code [leave blank if not required]: \" GH_2FA_CODE; GH_RESP=\"$(curl -sSi -u \"${USER:-${NAME}}\" -d \"{\\\"scopes\\\":[\\\"repo\\\"], \\\"note\\\":\\\"Generated on $(date +\"%Y-%m-%d %H:%M:%S %z\") with 'git token' from $(hostname).\\\"}\" --header \"X-GitHub-OTP: ${GH_2FA_CODE}\" https://api.github.com/authorizations)\"; [ \"$(echo \"${GH_RESP}\" | head -1 | grep \"HTTP/1.1 2\")\" != \"\" ] && OK=true || OK=false; if ! $OK; then git imp-error \"Error creating a GitHub token.\"; exit 1; fi; TKN=$(echo ${GH_RESP} | sed -e \"s/.*\\\"token\\\": \\\"\\([a-zA-Z0-9]*\\)\\\".*/\\1/\"); git imp-warn \"New token created successfully.\"; read -s -n 1 -p \"$(echo \"I can save it for later use if you like so:\n - in the (l)ocal git config of the current repo,\n - in the (g)lobal git config, or\n - (n)owhere: you'll manage it.\nPlease type L, G or N\n \n\")\" TARGET; case $TARGET in L|l) git config --local github.token ${TKN} && git imp-warn 'GitHub token successfully saved in the git config file of the current repo.';; G|g) git config --global github.token ${TKN} && git imp-warn '\nGitHub token successfully saved in the global git config file.';; *) git imp-warn \"You might want to store it in a system variable named GITHUB_TOKEN for persistency:\"; git imp-warn \"\\$ export GITHUB_TOKEN=${TKN}\";; esac; git imp-warn \"${GIT_ADMIN_NOTE}\"; [ \"${1}\" == \"--location\" ] && echo ${TKN_FROM} || echo ${TKN}; }; f"

  imp-get-own-and-repo = !"f() { OWN_AND_REPO=\"$(git config --get remote.origin.url | sed \"s|.*[/:]\\(.*/.*\\)\\.git|\\1|\")\"; [ -n \"${OWN_AND_REPO}\" ] && echo \"${OWN_AND_REPO}\" || git imp-error \"Remote origin url not found.\"; }; f"

  imp-sanitize-json-resp = !"f() { echo \"{\\\"body\\\":${@}}\" | tr '\\n' ' ' | tr -d \"'\"| sed -e \"s/[^[:print:]]/ /g\" -e \"s/\\\\\\\\\\*//g\" -e \"s/\\\\\\\\/\\\\\\\\\\\\\\\\/g\" -e \"s/\\`\\`\\`[^\\`]*\\`\\`\\`//g\" -e \"s/[[:space:]][[:space:]]*/ /g\"; }; f" #'

  imp-install-python-deps = !"sudo pip install python-dateutil"

# This line has to be at the bottom of the file, so that configuration defined
# in '.gitconfig.local' always takes precedence.
# DOC: https://git-scm.com/docs/git-config#_includes
[include]
  path = ./.gitconfig.local
